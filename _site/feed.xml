<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-04-25T15:55:29+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">TheRouter - 移动端模块化解决方案</title><subtitle>TheRouter 是一个 Kotlin 编写，用于 Android 模块化开发的一整套解决方案框架。</subtitle><entry><title type="html">Harmony 动态路由框架：TheRouter 即将开源</title><link href="http://localhost:4000/docs/2025/03/24/01" rel="alternate" type="text/html" title="Harmony 动态路由框架：TheRouter 即将开源" /><published>2025-03-24T00:00:00+08:00</published><updated>2025-03-24T00:00:00+08:00</updated><id>http://localhost:4000/docs/2025/03/24/01</id><content type="html" xml:base="http://localhost:4000/docs/2025/03/24/01"><![CDATA[<p><code class="language-plaintext highlighter-rouge">TheRouter</code> 是一个用于移动端APP，包括 Android、iOS、Harmony 三端的模块化、组件化开发的一整套解决方案框架。提供了三端高一致性，对移动端开发者更友好，让开发人员更适应，使用起来也更顺手。在鸿蒙上， TheRouter 基于HMRouter做了深度定制，不仅支持平台化应用实现组件化、跨模块调用、动态化等功能的集成等功能基础上，还提供了编译时安全检查、支持动态路由下发与修改、路由 Path 一对多等高度动态能力。</p>

<p>Github: <a href="https://github.com/HuolalaTech/hll-wp-therouter-harmony/">https://github.com/HuolalaTech/hll-wp-therouter-harmony/</a> <br />
官网：<a href="http://therouter.cn/">http://therouter.cn/</a></p>

<p>TheRouter Harmony 核心功能具备如下能力：</p>

<ul>
  <li>页面导航跳转能力(Navigator)</li>
  <li>跨模块依赖注入能力(ServiceProvider)</li>
  <li>动态化能力(ActionManager)</li>
</ul>

<p><br /></p>

<h3 id="一为什么要使用-therouter">一、为什么要使用 TheRouter</h3>

<p>路由是现如今移动端开发中必不可少的功能，尤其是企业级APP，可以用于将多模块页面跳转的强依赖关系解耦，同时减少跨团队开发的互相依赖问题。</p>

<p>对于大型 APP 开发，基本都会选用模块化(或组件化)方式开发，对于模块间解耦要求更高。 <code class="language-plaintext highlighter-rouge">TheRouter</code> 是一整套完全面向模块化开发的解决方案，不仅能支持常规的模块依赖解耦、页面跳转，同时提供了模块化过程中常见问题的解决办法。</p>

<p><br /></p>

<h4 id="11-therouter-鸿蒙端的三大能力">1.1 TheRouter 鸿蒙端的三大能力</h4>

<p>Navigator：</p>

<ul>
  <li>支持 <code class="language-plaintext highlighter-rouge">Path</code> 与页面多对一关系或一对一关系，可用于解决多端path统一问题</li>
  <li>页面 <code class="language-plaintext highlighter-rouge">Path</code> 支持正则表达式声明</li>
  <li>支持 <code class="language-plaintext highlighter-rouge">json</code> 格式路由表导出</li>
  <li>路由表支持为页面添加注释说明</li>
  <li>支持动态下发 <code class="language-plaintext highlighter-rouge">json</code> 路由表，降级任意页面为H5</li>
  <li>支持页面跳转拦截处理</li>
  <li>支持使用路由跳转到第三方 SDK 中的页面</li>
</ul>

<p>ServiceProvider：</p>

<ul>
  <li>支持跨模块依赖注入</li>
  <li>支持自定义注入项的创建规则，依赖注入可自定义参数</li>
  <li>支持注入对象缓存，多次注入，只会 new 一次对象</li>
</ul>

<p>ActionManager：</p>

<ul>
  <li>支持全局回调配置</li>
  <li>支持多对一链式响应</li>
  <li>支持优先级响应</li>
  <li>方法支持返回值与入参</li>
  <li>支持记录调用路径，解决调试期观察者模式无法追踪 <code class="language-plaintext highlighter-rouge">Observable</code> 的问题</li>
</ul>

<p><br /></p>

<h3 id="二鸿蒙路由方案">二、鸿蒙路由方案</h3>

<p>根据华为官方文档建议，从API 10开始，推荐使用 <code class="language-plaintext highlighter-rouge">NavPathStack</code> 配合 <code class="language-plaintext highlighter-rouge">navDestination</code> 属性进行页面路由。所以 <code class="language-plaintext highlighter-rouge">TheRouter</code> 也是按照这个方案实现的，如果你的项目还是使用 <code class="language-plaintext highlighter-rouge">ohos.router</code> 组件，建议尽早迁移。<br />
详细内容请查看华为官方文档：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-router">https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-router</a></p>

<p>无论哪个平台，路由的本质就是一个 Map，或者说是字典。其中 key 是，页面的 path，value 是路由项。对于 Action、ServiceProvider，也都是一样。<br />
所以在鸿蒙上最核心的重点，是实现在编译期将注解 path 关联到具体的路由项，使其产生一个一对多或一对一的对应关系。其次就是要考虑如何与系统自带的路由表兼容，遵循系统方案而不是完全打造一套，否则可能引起将来的不确定性。  <br />
在 TheRouter 中，通过编译期的 <code class="language-plaintext highlighter-rouge">hvigor</code> 插件，解析全部的注解关键字，并将获取到的内容保存下来，在应用编译完成后，参照系统的路由表格式，生成一份增量的路由表，聚合到系统的路由表内。正是因为这样，才能做到兼容第三方SDK，正常跳转到第三方页面。既然第三方都能跳转，那么其他的二方、或自己的独立模块自然也就可以正常跳转了。</p>

<p><br /></p>

<h3 id="三使用-therouter-页面跳转">三、使用 TheRouter 页面跳转</h3>

<h4 id="31-声明路由项">3.1 声明路由项</h4>

<p>如果一个页面允许被路由打开，则需要使用注解 <code class="language-plaintext highlighter-rouge">@Route</code> 声明路由项，每个页面允许声明多个路由项，也就是一对多的能力，极大降低多端路由统一时的业务影响面。</p>

<p><strong>参数释义</strong></p>

<ul>
  <li><strong>path</strong>: 路由path 【必传】。 <br />
 建议是一个url，并推荐三端url统一。path内支持使用正则表达式，允许多个path对应同一个Page。</li>
  <li><strong>description</strong>: 页面描述【可选】。<br />
 会被记录到路由表中，方便后期排查的时候知道每个path或Page是什么业务。</li>
  <li><strong>params</strong>: 页面参数【可选】。 <br />
 自动写入当前页面参数中，允许写在路由表中动态下发修改默认值，或通过路由跳转时代码传入。</li>
  <li><strong>launchMode</strong>: 当前页的启动方式【可选】。 <br />
 启动模式，可选项：’STANDARD’(默认)、’MOVE_TO_TOP_SINGLETON’、’POP_TO_SINGLETON’、’NEW_INSTANCE’。</li>
</ul>

<p><br /></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Route</span><span class="p">({</span> <span class="na">path</span><span class="p">:</span> <span class="nx">BaseConstant</span><span class="p">.</span><span class="nx">MAIN_PAGE</span><span class="p">,</span> <span class="na">description</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Demo首页</span><span class="dl">'</span><span class="p">,</span> <span class="na">params</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">路由表默认参数</span><span class="dl">"</span><span class="p">],</span> <span class="na">launchMode</span><span class="p">:</span><span class="dl">'</span><span class="s1">STANDARD</span><span class="dl">'</span> <span class="p">})</span>
<span class="p">@</span><span class="nd">Component</span>
<span class="k">export</span> <span class="nx">struct</span> <span class="nx">MainPage</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="32-发起页面跳转">3.2 发起页面跳转</h4>

<p>传入的参数可以是 <code class="language-plaintext highlighter-rouge">string</code> 和基本数据类型、也可以是<code class="language-plaintext highlighter-rouge">ESObject</code>对象。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TheRouter</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://therouter.com/home</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">withNumber</span><span class="p">(</span><span class="dl">"</span><span class="s2">key1</span><span class="dl">"</span><span class="p">,</span> <span class="mi">12345678</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">withString</span><span class="p">(</span><span class="dl">"</span><span class="s2">key2</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">参数</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">withBoolean</span><span class="p">(</span><span class="dl">"</span><span class="s2">key3</span><span class="dl">"</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">with</span><span class="p">({</span><span class="na">xxx</span><span class="p">:</span><span class="nx">xxx</span><span class="p">})</span> 
         <span class="c1">// navigation、replace、pop 均可以额外传入 callback 参数，对当前跳转的个状态回调</span>
        <span class="p">.</span><span class="nf">navigation</span><span class="p">();</span>

        <span class="c1">// 替换页面（相当于先 pop 再 push）</span>
        <span class="p">.</span><span class="nf">replace</span><span class="p">();</span>

        <span class="c1">// 关闭当前页</span>
        <span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
       
</code></pre></div></div>

<p><br /></p>

<h4 id="33-路由表生成规则">3.3 路由表生成规则</h4>

<p>如果两条路由的 <code class="language-plaintext highlighter-rouge">path</code> 完全相同，则认为是同一条路由，<strong>不会考虑参数是否相同</strong>。 <br />
路由表生成规则：编译期按照如下顺序取<strong>并集</strong>。</p>

<p><strong>覆盖规则</strong>： <br />
根据如下顺序，如果相同，后者可以覆盖前者的路由表规则。</p>

<ol>
  <li>编译期解析注解生成路由表</li>
  <li>首先取 <code class="language-plaintext highlighter-rouge">业务模块(har/hap)</code> 中的路由表</li>
  <li>再取 主<code class="language-plaintext highlighter-rouge">hsp module</code> 代码中的路由表</li>
  <li>最后取 <code class="language-plaintext highlighter-rouge">resources/base/profile/RouteMap.json</code> 文件中声明的路由表。
    <ul>
      <li>如果编译期没有这个文件，会生成一份默认路由表放在这个目录内（编译完成后如果没有配置保留，会自动删掉）；如果有，会将路由表合并。</li>
    </ul>
  </li>
  <li>运行时线上动态下发的路由表
    <ul>
      <li>路由表允许线上动态下发，将覆盖本地路由表，详见 【3.4 动态路由表的设计与使用】</li>
    </ul>
  </li>
</ol>

<p>如果编译期没有这个文件，会生成一份默认路由表放在这个目录内（编译完成后如果没有配置保留，会自动删掉）；如果有，会将路由表合并，因此，对于没办法修改代码的第三方SDK内部，如果希望通过路由打开，只需要手动在 <code class="language-plaintext highlighter-rouge">RouteMap.json</code> 文件中声明，就能通过路由打开了。</p>

<p><br /></p>

<h4 id="34-动态路由表的设计与使用">3.4 动态路由表的设计与使用</h4>

<p><code class="language-plaintext highlighter-rouge">TheRouter</code> 的路由表是动态添加的，项目每次编译后，会在 app 内生成一份当前模块的全量路由表。这个路由表也可以后续通过远程下发的方式使用，例如远端可以针对不同的APP版本，下发不同的路由表达到配置目的。这样如果将来线上某些页面发生Crash，可以通过将这个页面的落地页替换为H5的方式，临时解决这类问题。  <br />
<br /></p>

<p>有两种推荐的远程下发方式可供使用方选择：</p>

<ol>
  <li>将打包系统与配置系统打通，每次新版本打包后自动将所有模块(hsp、har、hap) <code class="language-plaintext highlighter-rouge">resource/rawfile/</code> 目录中的路由表文件上传到配置系统，聚合成一个 json 后，下发给对应版本 APP 。优点在于全自动不会出错。</li>
  <li>配置系统无法打通，线上手动下发需要修改的路由项，因为 <code class="language-plaintext highlighter-rouge">TheRouter</code> 会自动用最新下发的路由项覆盖包内的路由项。优点在于精确，且流量资源占用小。 <br />
<br /></li>
</ol>

<p><strong>动态路由限制</strong> ：准确的说，应该是鸿蒙系统的限制。在鸿蒙上，路由表必须是静态的并且在编译期确定下来。TheRouter Harmony 做了一些黑科技处理，允许动态加载一个或多个路由表，但是动态加载的路由页面必须是在编译期就已经存在的，不能凭空新增（类似 <code class="language-plaintext highlighter-rouge">Android</code> 的 <code class="language-plaintext highlighter-rouge">Activity</code>，在编译后就不能再改或新增注册清单文件了）。</p>

<p><br /></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 与Android逻辑不同，此代码 必须 在页面打开之前，路由初始化之后调用。 建议紧跟 TheRouter.init() 调用</span>
<span class="nx">TheRouter</span><span class="p">.</span><span class="nf">setRouteMapInitTask</span><span class="p">(</span><span class="nx">task</span><span class="p">:</span> <span class="p">(</span><span class="nx">map</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">RouteItem</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">);</span>

<span class="cm">/** 
 * 此处的 map 就是当前应用的路由表全量，
 * 当获取到远端路由表以后，把路由表继续传入map中，有重复项可自动覆盖
 */</span>
<span class="nx">TheRouter</span><span class="p">.</span><span class="nf">setRouteMapInitTask</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 此处为纯业务逻辑，每家公司远端配置方案可能都不一样</span>
    <span class="kd">const</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">Connfig</span><span class="p">.</span><span class="nf">doHttp</span><span class="p">(</span><span class="dl">"</span><span class="s2">routeMap</span><span class="dl">"</span><span class="p">);</span>
    <span class="c1">// 只需要将路由json返回给框架即可，不建议在任务中做耗时操作</span>
    <span class="k">return</span> <span class="nx">json</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="35-拦截器用法">3.5 拦截器用法</h4>

<p>框架内置四种自定义处理器可供业务场景定制，用于在路由跳转过程中，以切面的方式统一修改路由落地页参数信息。 <br />
Harmony 路由与 Android 路由的拦截器使用完全一致，可以直接参考【<a href="https://therouter.cn/docs/2022/08/28/01">Android 文档</a> 第三部分】。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 所有拦截器方法均在 TheRouter 类下，可以直接如下方式全局调用</span>
<span class="nx">TheRouter</span><span class="p">.</span><span class="nf">addNavigatorPathFixHandle</span><span class="p">()</span>

<span class="cm">/**
  * 应用场景：用于修复客户端上路由 path 错误问题。
  * 例如：相对路径转绝对路径，或由于服务端下发的链接无法固定https或http，但客户端代码写死了 https 的 path，就可以用这种方式统一。
  * 注：必须在 TheRouter.build() 方法调用前添加处理器，否则处理器前的所有path不会被修改。
  */</span>
<span class="k">static</span> <span class="nf">addNavigatorPathFixHandle</span><span class="p">(</span><span class="nx">handle</span><span class="p">:</span> <span class="nx">NavigatorPathFixHandle</span><span class="p">);</span>

<span class="cm">/**
  * 页面替换器
  * 应用场景：需要将某些path指定为新链接的时候使用。 也可以用在修复链接的场景，但是与 path 修改器不同的是，修改器通常是为了解决通用性的问题，替换器只在页面跳转时才会生效，更多是用来解决特性问题。
  *
  * 例如模块化的时候，首页壳模板组件中开发了一个SplashActivity广告组件作为应用的MainActivity，在闪屏广告结束的时候自动跳转业务首页页面。 但是每个业务不同，首页页面的 Path 也不相同，而不希望让每个业务线自己去改这个首页壳模板组件，此时就可以组件中先写占位符https://kymjs.com/splash/to/home，让接入方通过 Path 替换器解决。
  * 注：必须在 TheRouter.build().navigation() 方法调用前添加处理器，否则处理器前的所有跳转不会被替换。
  */</span>
<span class="k">static</span> <span class="nf">addPathReplaceInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">:</span> <span class="nx">PathReplaceInterceptor</span><span class="p">);</span>


<span class="cm">/**
  * 路由替换器
  * 应用场景：常用在未登录不能使用的页面上。例如访问用户钱包页面，在钱包页声明的时候，可以在路由表上声明本页面是需要登录的，在路由跳转过程中，如果落地页是需要登录的，则先替换路由到登录页，同时将原落地页信息作为参数传给登录页，登录流程处理完成后可以继续执行之前的路由操作。
  *
  * 路由替换器的拦截点更靠后，主要用于框架已经从路由表中根据 path 找到路由以后，对找到的路由做操作。
  *
  * 这种逻辑在所有页面跳转前写不太合适，以前的做法通常是在落地页写逻辑判断用户是否具有权限，但其实在路由层完成更合适。
  * 注：必须在 TheRouter.build().navigation() 方法调用前添加处理器，否则处理器前的所有跳转不会被替换。
  */</span>
<span class="k">static</span> <span class="nf">addRouterReplaceInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">:</span> <span class="nx">RouterReplaceInterceptor</span><span class="p">);</span>

<span class="cm">/**
  * 路由AOP拦截器
  * 与前三个处理器不同的点在于，路由的AOP拦截器全局只能有一个。用于实现AOP的能力，在整个TheRouter跳转的过程中，跳转前，目标页是否找到的回调，跳转时，跳转后，都可以做一些自定义的逻辑处理。
  *
  * 使用场景：场景很多，最常用的是可以拦截一些跳转，例如debug页面在生产环境不打开，或定制startActivity跳转方法。
  */</span>
<span class="k">public</span> <span class="nf">setRouterInterceptor</span><span class="p">(</span><span class="nx">interceptor</span><span class="p">:</span> <span class="p">(</span><span class="nx">route</span><span class="p">:</span> <span class="nx">RouteItem</span><span class="p">,</span> <span class="nx">callback</span><span class="p">:</span> <span class="p">(</span><span class="nx">route</span><span class="p">:</span> <span class="nx">RouteItem</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="36-高级用法">3.6 高级用法</h4>

<p>TheRouter同时支持更多页面跳转能力：</p>

<ul>
  <li>为第三方库里面的页面添加路由表，达到对某些页面降级替换的目的；</li>
  <li>跳转过程拦截器（总共四层，可根据实际需求使用）；</li>
  <li>跳转结果回调；</li>
</ul>

<p><br /></p>

<h3 id="四跨模块依赖注入-serviceprovider-的设计">四、跨模块依赖注入 ServiceProvider 的设计</h3>

<p>对于模块化开发中跨模块的调用，我们推荐采用 <a href="https://zh.m.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">SOA(面向服务架构)</a> 的设计方式，服务调用方与使用方完全隔离，调用模块外的能力不需要关注能力的提供者是谁。<br />
<code class="language-plaintext highlighter-rouge">ServiceProvider</code> 的核心设计思想也是这样的，目前服务间的调用协议采用接口的方式。当然，也可以兼容不通过接口下沉而是直接调用的情况。</p>

<p><img src="https://cdn.kymjs.com:8843/qiniu/images/blog_image/therouter/3.jpeg" class="blog-img" /></p>

<ul>
  <li>服务提供方负责提供服务，不需要关心调用方是谁会在何时调用自己。</li>
  <li>服务的使用方只关注服务本身，不需要关心这个服务是谁提供的，只需要只能服务能提供哪些能力即可。</li>
</ul>

<p>例如上面的图片：拉拉需要使用录音的服务，小货则向外提供一个录音的服务，由<code class="language-plaintext highlighter-rouge">TheRouter</code>的<code class="language-plaintext highlighter-rouge">ServiceProvider</code>负责撮合。</p>

<p><br /></p>

<h4 id="41-服务使用方拉拉">4.1 服务使用方：拉拉</h4>

<p>她无需关心，<code class="language-plaintext highlighter-rouge">IRecordService</code> 这个接口服务是谁提供的，他只需要知道自己需要使用这样的一个服务就行了。<br />
注：如果没有提供服务的提供方，<code class="language-plaintext highlighter-rouge">TheRouter.get()</code> 可能返回 <code class="language-plaintext highlighter-rouge">undefined</code></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">TheRouter</span><span class="p">.</span><span class="kd">get</span><span class="o">&lt;</span><span class="nx">IRecordService</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">BaseConstant</span><span class="p">.</span><span class="nx">CLASS_SERVICE</span><span class="p">)?.</span><span class="nf">doRecord</span><span class="p">()</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="42-服务提供方小货">4.2 服务提供方：小货</h4>

<p>服务提供方需要声明一个提供服务的方法，用 <code class="language-plaintext highlighter-rouge">@ServiceProvider</code> 注解标记，并需要实现接口 <code class="language-plaintext highlighter-rouge">IServiceProvider</code>。</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 类名不限定，任意名字都行</span>
<span class="c1">// 所有的 ServiceProvider 必须实现 IServiceProvider 接口</span>
<span class="c1">// 多次添加重复serviceName，框架会保证安全，在编译时报错</span>
<span class="p">@</span><span class="nd">ServiceProvider</span><span class="p">({</span> <span class="na">serviceName</span><span class="p">:</span> <span class="nx">BaseConstant</span><span class="p">.</span><span class="nx">CLASS_SERVICE</span><span class="p">,</span> <span class="na">singleton</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nc">CustomService</span> <span class="k">implements</span> <span class="nx">IRecordService</span><span class="p">,</span> <span class="nx">IServiceProvider</span> <span class="p">{</span>

  <span class="nf">doRecord</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p><br /></p>

<p><strong>@ServiceProvider 参数释义</strong></p>

<ul>
  <li><strong>serviceName</strong>: 服务名 【必传】。 <br />
 服务的唯一标识。如果重复，在编译期会直接报错。</li>
  <li><strong>singleton</strong>: 默认false【可选】。<br />
 服务提供方提供出的服务是否为单例。</li>
</ul>

<p><br /></p>

<h3 id="五动态化能力-action-的设计">五、动态化能力 Action 的设计</h3>

<p><code class="language-plaintext highlighter-rouge">Action</code> 本质是一个全局的系统回调，主要用于预埋的一系列操作，例如：弹窗、上传日志、清理缓存。<br />
与 Android 系统自带的广播通知类似，你可以在任何地方声明动作与处理方式。并且所有 <code class="language-plaintext highlighter-rouge">Action</code> 都是可以被跟踪的，只要你愿意，可以在日志中将所有的动作调用栈输出，以方便调试使用，这样在一定程度上可以解决观察者模式带来的通病：<strong>无法追踪 <code class="language-plaintext highlighter-rouge">Observable</code> 的问题</strong>。</p>

<p><br /></p>

<h4 id="51-action-使用">5.1 Action 使用</h4>

<p>声明一个 Action：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// action建议遵循一定的格式</span>
<span class="kd">const</span> <span class="k">readonly</span> <span class="nx">ACTION</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">therouter://action/xxx</span><span class="dl">"</span>

<span class="c1">// action既可以放在ServiceProvider里面，也可以单独放在任意类中，但不能是top-level函数，这一点与Android不同</span>
<span class="c1">// action函数允许有返回值，可以做耗时操作</span>
<span class="c1">// 多次添加重复action，每个action的方法都会执行，但最终只会返回优先级最高的方法的返回值</span>
<span class="p">@</span><span class="nd">Action</span><span class="p">({</span> <span class="na">action</span><span class="p">:</span> <span class="nx">ACTION</span> <span class="p">})</span>
<span class="k">public</span> <span class="nf">test</span><span class="p">(</span><span class="nx">par</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">返回入参：</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">par</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p><br /></p>

<p>执行一个 Action：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// action建议遵循一定的格式</span>
<span class="kd">const</span> <span class="nx">val</span> <span class="nx">ACTION</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">therouter://action/xxx</span><span class="dl">"</span>

<span class="c1">// 如果执行了一个没有被声明的Action，则不会有任何动作</span>
<span class="c1">// 这里的"hello"字符串，是根据action定义时有一个入参，所以调用时需要传入这个参数</span>
<span class="nx">TheRouter</span><span class="p">.</span><span class="nx">action</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">ACTION</span><span class="p">,</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">).</span><span class="nf">then</span><span class="p">((</span><span class="nx">str</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">str</span><span class="p">;</span>
<span class="p">})</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>@Action 参数释义</strong></p>

<ul>
  <li><strong>action</strong>: 事件名 【必传】。 <br />
 当前函数需要响应的action。如果同一个action有多个函数订阅，会在响应时根据优先级决定先后顺序。</li>
  <li><strong>priority</strong>: 优先级(number类型)，默认5【可选】。<br />
 数字越大，优先级越高。</li>
</ul>

<p><br /></p>

<h4 id="52-客户端动态响应使用场景">5.2 客户端动态响应使用场景</h4>

<p><strong>如果仅客户端使用</strong>，常用的场景可能是：当用户执行某些操作（打开某个页面、H5点击某个按钮、动态页面配置的点击事件）时，将会自动触发，执行预埋的 Action 逻辑。</p>

<p><strong>如果与服务端链路打通</strong>，这个能力其实是需要整个公司的配合，比如有一套类似智慧大脑的方案，可以基于客户端过去的一些埋点数据，智能推断出用户下一步要做的事情，然后通过长连接直接向客户端下发指令做某些事情。那么通过客户端预埋的页面跳转、弹窗、清缓存、退出登录等等操作，就可以通过服务端指令进行操作，则就是一套完整的动态化方案。</p>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/actionmanager.png" class="blog-img" /></p>

<p><br /></p>

<h3 id="六从其他路由迁移至-therouter">六、从其他路由迁移至 TheRouter</h3>

<h4 id="61-迁移工具一键迁移">6.1 迁移工具一键迁移？</h4>

<p><code class="language-plaintext highlighter-rouge">TheRouter</code> 在 Android 项目上提供了图形化界面的迁移工具，可以一键从其他路由迁移到<code class="language-plaintext highlighter-rouge">TheRouter</code>。</p>

<p>鸿蒙当然也提供了相同的能力，你可以在插件市场搜索，直接安装。安装好以后，点击 IDE 顶部的 Tool 菜单，找到迁移工具。</p>

<p><br /></p>

<h4 id="62-与其他路由对比">6.2 与其他路由对比</h4>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>功能</th>
      <th>TheRouter</th>
      <th>HMRouter</th>
      <th>Navigation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>具备三端高一致性</td>
      <td>✔️</td>
      <td>✖️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>注解生成路由表</td>
      <td>✔️</td>
      <td>✔️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>路由path支持正则表达式</td>
      <td>✔️</td>
      <td>✔️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>指定拦截器</td>
      <td>✔️（四大拦截器可根据业务定制）</td>
      <td>✔️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>导出路由表</td>
      <td>✔️（路由文档支持添加注释描述）</td>
      <td>✔️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>支持跨模块调用</td>
      <td>✔️</td>
      <td>✔️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>动态修改路由信息</td>
      <td>✔️</td>
      <td>✖️(未提供功能接口)</td>
      <td>✔️(限制高，需提前定义，通过if/else修改实现)</td>
    </tr>
    <tr>
      <td>远端路由表下发</td>
      <td>✔️</td>
      <td>✖️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>多 Path 对应同一页面（低成本实现双端path统一）</td>
      <td>✔️</td>
      <td>✖️</td>
      <td>✖️</td>
    </tr>
    <tr>
      <td>支持使用路由打开第三方SDK页面</td>
      <td>✔️</td>
      <td>✖️</td>
      <td>✖️</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="七总结">七、总结</h3>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">TheRouter</code> 并不仅仅是一个小巧灵活的路由库，而是一整套 <code class="language-plaintext highlighter-rouge">Android</code>、<code class="language-plaintext highlighter-rouge">iOS</code>、<code class="language-plaintext highlighter-rouge">Harmony</code> 三端完整的移动端解决方案，对移动端开发者更友好，上手开发适应性更强。使用 <code class="language-plaintext highlighter-rouge">TheRouter</code> 能够解决几乎全部的模块化过程中会遇到的问题。<br />
对于现有的路由框架，我们也在最大限度支持平滑迁移。你也可以在 <code class="language-plaintext highlighter-rouge">Github</code> <code class="language-plaintext highlighter-rouge">issue</code> 中提出需求，我们评估后会尽快支持，也欢迎任何人提供 <code class="language-plaintext highlighter-rouge">Pull Requests</code>。</p>

<p><br /></p>

<p>更多问题请加群沟通：<br />
<br />
<img src="https://cdn.kymjs.com:8843/therouter_assets/img/therouter_wx_group.png" width="320" /></p>

<p><br /></p>]]></content><author><name></name></author><category term="news" /><category term="news" /><summary type="html"><![CDATA[TheRouter 鸿蒙动态路由框架即将开源。]]></summary></entry><entry><title type="html">接入鸿蒙 TheRouter</title><link href="http://localhost:4000/docs/2025/03/23/01" rel="alternate" type="text/html" title="接入鸿蒙 TheRouter" /><published>2025-03-23T00:00:00+08:00</published><updated>2025-03-23T00:00:00+08:00</updated><id>http://localhost:4000/docs/2025/03/23/01</id><content type="html" xml:base="http://localhost:4000/docs/2025/03/23/01"><![CDATA[<p><code class="language-plaintext highlighter-rouge">TheRouter</code> 是货拉拉基于HMRouter深度定制的开源路由框架，提供了 Android、iOS、Harmony 三端高一致性使用，在支持平台化应用实现组件化、跨模块调用、动态化等功能的集成等功能基础上，支持动态路由下发、编译时安全检查、路由Path一对多等高度动态能力。</p>

<p>Github: <a href="https://github.com/HuolalaTech/hll-wp-therouter-harmony/">https://github.com/HuolalaTech/hll-wp-therouter-harmony/</a> <br />
官网：<a href="http://therouter.cn/">http://therouter.cn/</a></p>

<p><br /></p>

<h2 id="开始之前">开始之前</h2>

<p>如果你的是新项目，请先记住一点：<strong>plugin、router 两个依赖的版本号必须保持一致</strong>，请继续往下看接入步骤。</p>

<p><br /></p>

<h2 id="查看最新版本">查看最新版本</h2>

<p>TheRouter 的版本分为两种，稳定版和 rc版，一般不追求新功能我们就用稳定版就行，可以在官网看到最新的版本号和各种版本的说明：<a href="https://therouter.cn/docs/2022/09/06/01">https://therouter.cn/docs/2022/09/06/01</a></p>

<p><br /></p>

<h2 id="接入">接入</h2>

<p>在工程根目录命令行引入依赖库和插件库（必须全部依赖，不能只使用其中一个）。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 引入代码库依赖
ohpm i @hll/therouter   

// 引入插件依赖
npm i therouter-plugin
</code></pre></div></div>

<p><br /><br /></p>

<h3 id="第一步接入编译插件">第一步：接入编译插件</h3>

<ol>
  <li>打开项目根目录的 <code class="language-plaintext highlighter-rouge">hvigor/hvigor-config.json5</code>，检查 <code class="language-plaintext highlighter-rouge">dependencies</code> 中是否已经加入了依赖，一般为 <code class="language-plaintext highlighter-rouge">"therouter-plugin": "x.x.x"</code>。</li>
  <li>打开工程 <strong>所有</strong> 模块（hsp、hap、har）的 <code class="language-plaintext highlighter-rouge">hvigorfile.ts</code> 文件。</li>
  <li>在 <code class="language-plaintext highlighter-rouge">plugins</code> 中加入如下对应的依赖</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 如果是 hap，则类似如下依赖</span>
<span class="kn">import</span> <span class="err">{</span> <span class="nn">hapPlugin</span> <span class="o">}</span> <span class="n">from</span> <span class="s">"therouter-plugin"</span><span class="o">;</span>
<span class="n">export</span> <span class="k">default</span> <span class="o">{</span>
  <span class="nl">plugins:</span> <span class="o">[</span><span class="n">hapPlugin</span><span class="o">()]</span>
<span class="o">}</span>

<span class="c1">// 如果是 har，则类似如下依赖</span>
<span class="kn">import</span> <span class="err">{</span> <span class="nn">harPlugin</span> <span class="o">}</span> <span class="n">from</span> <span class="s">"therouter-plugin"</span><span class="o">;</span>
<span class="n">export</span> <span class="k">default</span> <span class="o">{</span>
  <span class="nl">plugins:</span> <span class="o">[</span><span class="n">harPlugin</span><span class="o">()]</span>
<span class="o">}</span>

<span class="c1">// 如果是 hap，则类似如下依赖</span>
<span class="kn">import</span> <span class="err">{</span> <span class="nn">hapPlugin</span> <span class="o">}</span> <span class="n">from</span> <span class="s">"therouter-plugin"</span><span class="o">;</span>
<span class="n">export</span> <span class="k">default</span> <span class="o">{</span>
  <span class="nl">plugins:</span> <span class="o">[</span><span class="n">hapPlugin</span><span class="o">()]</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /><br /></p>

<h3 id="第二步检查依赖是否引入">第二步：检查依赖是否引入</h3>

<ol>
  <li>打开 <strong>工程根目录</strong> 的 <code class="language-plaintext highlighter-rouge">oh-package.json5</code> 文件。</li>
  <li>检查 <code class="language-plaintext highlighter-rouge">dependencies</code> 中，是否已经加入了依赖，一般为：<code class="language-plaintext highlighter-rouge">"@hll/therouter": "x.x.x"</code></li>
</ol>

<p><br /><br /></p>

<h2 id="使用">使用</h2>

<h4 id="1-初始化">1. 初始化</h4>

<p>在项目入口的 <code class="language-plaintext highlighter-rouge">UIAbility</code> 的 <code class="language-plaintext highlighter-rouge">onCreate()</code> 中加入如下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onCreate</span><span class="o">(</span><span class="nl">want:</span> <span class="nc">Want</span><span class="o">,</span> <span class="nl">launchParam:</span> <span class="nc">AbilityConstant</span><span class="o">.</span><span class="na">LaunchParam</span><span class="o">):</span> <span class="kt">void</span> <span class="o">{</span>
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="2-定义页面容器">2. 定义页面容器</h4>

<p>TheRouter 按照华为推荐方案，基于系统 Navigation 实现，所以必须在页面中定义一个容器项 <code class="language-plaintext highlighter-rouge">TheRouterPage</code>，建议创建一个完全新的类作为入口并在 <code class="language-plaintext highlighter-rouge">/resources/base/profile/main_pages.json</code> 中配置这个类，复制如下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="err">{</span> <span class="nn">TheRouterPage</span> <span class="o">}</span> <span class="n">from</span> <span class="err">'</span><span class="nd">@hll</span><span class="o">/</span><span class="n">therouter</span><span class="err">'</span><span class="o">;</span>

<span class="nd">@Entry</span>
<span class="nd">@Component</span>
<span class="n">struct</span> <span class="nc">Index</span> <span class="o">{</span>
  <span class="n">build</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">RelativeContainer</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">TheRouterPage</span><span class="o">({</span>
        <span class="nl">stackId:</span> <span class="err">'</span><span class="no">XXXX</span><span class="err">'</span><span class="o">,</span>  <span class="c1">//【必传】可以自定义当前stack的名字，每个stack必须唯一</span>
        <span class="nl">root:</span> <span class="err">'</span><span class="n">path</span><span class="err">'</span>  <span class="c1">// 【必传】当前应用的首页 path，推荐按照一定格式定义页面path</span>
		<span class="c1">// 还有很多可选参数，详情请见文档</span>
      <span class="o">});</span>
    <span class="o">}</span>
    <span class="o">.</span><span class="na">height</span><span class="o">(</span><span class="err">'</span><span class="mi">100</span><span class="o">%</span><span class="err">'</span><span class="o">)</span>
    <span class="o">.</span><span class="na">width</span><span class="o">(</span><span class="err">'</span><span class="mi">100</span><span class="o">%</span><span class="err">'</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="3-声明路由">3. 声明路由</h4>

<p>给需要跳转的页面加上路由表声明</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Route</span><span class="o">({</span><span class="n">path</span> <span class="o">:</span> <span class="s">"http://therouter.com/home"</span><span class="o">})</span>
<span class="n">export</span> <span class="n">struct</span> <span class="nc">HomePage</span> <span class="o">{</span>
	<span class="n">xxx</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="4-发起跳转">4. 发起跳转</h4>

<p>在需要跳转页面的位置调用如下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span>
	<span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="s">"http://therouter.com/home"</span><span class="o">)</span>  
	<span class="o">.</span><span class="na">withString</span><span class="o">(</span><span class="sc">'k'</span><span class="o">,</span> <span class="sc">'v'</span><span class="o">)</span> <span class="c1">// 向落地页传参数（如果没参数，可不调用）</span>
	<span class="o">.</span><span class="na">with</span><span class="o">({</span> <span class="nl">hello:</span> <span class="err">'</span><span class="n">world</span><span class="err">'</span> <span class="o">})</span> <span class="c1">// 另一种方式传参</span>
	<span class="o">.</span><span class="na">navigation</span><span class="o">()</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="5-获取页面传参">5. 获取页面传参</h4>

<p>接收有两种形式：</p>

<ul>
  <li>通过注解自动接收，默认支持 String 和8种基本数据类型，也支持自定义对象的解析</li>
  <li>通过代码从路由中获取</li>
</ul>

<p>使用注解接收对象时，必须调用 TheRouter.inject(this) 。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 第一种：使用注解自动填充</span>
  <span class="c1">// 允许解析成8种基本数据类型或对应封装类</span>
  <span class="nd">@Autowired</span><span class="o">()</span>
  <span class="n">key1</span> <span class="o">:</span> <span class="n">string</span> <span class="o">=</span> <span class="err">''</span>

  <span class="c1">// 允许自定义传参key，如果不传默认是变量名作为key</span>
  <span class="nd">@Autowired</span><span class="o">(</span><span class="err">'</span><span class="n">hello</span><span class="err">'</span><span class="o">)</span>
  <span class="n">key1</span> <span class="o">:</span> <span class="n">string</span> <span class="o">=</span> <span class="err">''</span>

  <span class="c1">// 使用注解接收对象时，必须调用，建议放在 aboutToApper() 中调用。</span>
  <span class="nc">TheRouter</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
  
  
  
<span class="c1">// 第二种：通过代码从路由中获取</span>
  <span class="c1">// 可以在任何方法中调用，getCurrentParam() 返回值是个ESObject</span>
  <span class="kd">const</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">TheRouter</span><span class="o">.</span><span class="na">getCurrentParam</span><span class="o">()[</span><span class="sc">'k'</span><span class="o">];</span>   
  
</code></pre></div></div>

<p><br /><br /></p>]]></content><author><name></name></author><category term="docs" /><category term="入门教程" /><summary type="html"><![CDATA[新手零基础入门教程。]]></summary></entry><entry><title type="html">为 TheRouter 的 AGP8 编译加个速</title><link href="http://localhost:4000/docs/2024/10/31/01" rel="alternate" type="text/html" title="为 TheRouter 的 AGP8 编译加个速" /><published>2024-10-31T00:00:00+08:00</published><updated>2024-10-31T00:00:00+08:00</updated><id>http://localhost:4000/docs/2024/10/31/01</id><content type="html" xml:base="http://localhost:4000/docs/2024/10/31/01"><![CDATA[<p>内容请见：</p>

<p>《为 TheRouter 的 AGP8 编译加个速》<br />
<a href="https://kymjs.com/code/2024/10/31/01/">https://kymjs.com/code/2024/10/31/01/</a></p>]]></content><author><name>张涛</name></author><category term="session" /><category term="原理与项目实践讲解" /><summary type="html"><![CDATA[AGP8 的变更应该很多人都知道了，移除了 Transform API，所以很多 class 操作类的插件代码都需要改了。]]></summary></entry><entry><title type="html">新版本编译改动</title><link href="http://localhost:4000/docs/2024/07/22/01" rel="alternate" type="text/html" title="新版本编译改动" /><published>2024-07-22T00:00:00+08:00</published><updated>2024-07-22T00:00:00+08:00</updated><id>http://localhost:4000/docs/2024/07/22/01</id><content type="html" xml:base="http://localhost:4000/docs/2024/07/22/01"><![CDATA[<h2 id="背景">背景</h2>
<p>从<code class="language-plaintext highlighter-rouge">1.2.3</code>版本开始，我们对<code class="language-plaintext highlighter-rouge">TheRouter</code>编译过程做了大量优化，同时适配了<code class="language-plaintext highlighter-rouge">Gradle</code>的<code class="language-plaintext highlighter-rouge">4.x-9.x</code>全部版本，理论上更新的版本或更老的版本也能支持，只是没有去测试。</p>

<p><br /><br /></p>

<h2 id="130版本改动">1.3.0版本改动</h2>

<ol>
  <li>由于新版本 Android Studio 强制使用 Java 17，TheRouter 从 1.3.0 开始全部使用 JDK17 编译，你需要更新编译 JDK 版本。</li>
  <li>新增编译选项（请在理解<a href="https://kymjs.com/code/2024/10/31/01/">增量实现原理</a>的前提下使用）：
    <ul>
      <li><strong>forceIncremental</strong>：bool值, 强制开启增量编译。增量编译默认只在debug模式并且有缓存时开启，如果强制开启增量编译，不论debug还是release都会启用增量。</li>
      <li><strong>incrementalCachePath</strong>：String值, 增量编译缓存路径。取工程根目录的相对路径，例如配置incrementalCachePath = “test”，则会在工程中新建一个名为test的文件夹。如不配置，默认是在app/build/目录下。   <strong>强烈建议 ：如果开启了强制增量编译，把缓存路径设置到工程目录下，并随git一起提交缓存数据，否则prd集成打包时，由于没有缓存又强制开启增量，会造成无法插入增量内容，运行时被降级为反射。</strong></li>
    </ul>
  </li>
</ol>

<h2 id="编译期选项">编译期选项</h2>

<p>老版本的<code class="language-plaintext highlighter-rouge">TheRouter</code>提供了不少编译期选项，可以通过手动在<code class="language-plaintext highlighter-rouge">local.properties</code>或<code class="language-plaintext highlighter-rouge">gradle.properties</code>文件中配置。从<code class="language-plaintext highlighter-rouge">1.2.3-rc1</code>版本开始，这些配置全部迁移到了app module的 <code class="language-plaintext highlighter-rouge">build.gradle</code> 内。你可以使用如下方式配置编译选项：</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 必须是app module内，引入 therouter 插件的 build.gradle 文件内</span>
<span class="c1">// 与android{}闭包同级，做编译配置</span>
<span class="n">TheRouter</span> <span class="o">{</span>
    <span class="c1">// 是否开启调试模式，默认不开启</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// 编译期检查路由表合法性，可选参数 warning(仅告警)/error(编译期抛异常)/delete(每次根据注解重新生成路由表)，不配置则不校验</span>
    <span class="n">checkRouteMap</span> <span class="o">=</span> <span class="s2">""</span><span class="o">;</span>
    <span class="c1">// 检查 FlowTask 是否有循环引用，可选参数 warning(仅打印日志)/error(编译期抛异常)，不配置则不校验</span>
    <span class="n">checkFlowDepend</span> <span class="o">=</span> <span class="s2">""</span><span class="o">;</span>
    <span class="c1">// 图形化输出当前的 FlowTask 依赖图，不配则不输出</span>
    <span class="n">showFlowDepend</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    
    <span class="c1">// 1.3.0新增，强制开启增量编译，详情见上方描述</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">forceIncremental</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// 1.3.0新增，自定义增量编译缓存路径，详情见上方描述</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">incrementalCachePath</span> <span class="o">=</span> <span class="s2">""</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<p><br /><br /></p>

<h2 id="编译缓存">编译缓存</h2>

<p>从<code class="language-plaintext highlighter-rouge">1.2.3-rc1</code>版本开始，所有编译均采用增量编译，且不再依赖<code class="language-plaintext highlighter-rouge">Gradle</code>的增量配置，所有增量均由框架内部实现，每次编译时会校验编译<code class="language-plaintext highlighter-rouge">jar</code>包与缓存数据是否一致，如果不一致才会去扫描有变更的<code class="language-plaintext highlighter-rouge">jar</code>包。因此，才能做到编译速度大幅提升。 <br />
缓存路径在：/app/build/therouter目录下。</p>

<p><strong>注：编译缓存仅在<code class="language-plaintext highlighter-rouge">debug</code>模式才会启用，你需要在 <code class="language-plaintext highlighter-rouge">build.gradle</code> 中开启调试模式（见步骤一）</strong></p>

<p><br /><br /></p>

<h2 id="默认服务提供者">默认服务提供者</h2>

<p>老版本的<code class="language-plaintext highlighter-rouge">TheRouter</code>，如果使用了一个不存在<code class="language-plaintext highlighter-rouge">ServiceProvider</code>的<code class="language-plaintext highlighter-rouge">Service</code>接口时，会默认创建一个接口的空实现类来避免空指针。但实际应用起来发现，并不能降低空指针的概率，反倒将原本应该在开发阶段就发现的问题延到了线上才发现。 <br />
从<code class="language-plaintext highlighter-rouge">1.2.3-rc1</code>开始，如果没有声明<code class="language-plaintext highlighter-rouge">@ServiceProvider</code>的接口，调用<code class="language-plaintext highlighter-rouge">TheRouter.get()</code>时，将会直接返回<code class="language-plaintext highlighter-rouge">null</code>。</p>

<p><br /><br /></p>

<h2 id="优化-ksp-编译速度">优化 KSP 编译速度</h2>

<p>从<code class="language-plaintext highlighter-rouge">1.2.3-rc1</code>版本开始，使用<code class="language-plaintext highlighter-rouge">KSP</code>处理注解也支持增量编译了。二次编译时，不会再次遍历全部类，而是只处理变更文件。 <br />
本优化由 <a href="https://github.com/hust-twj"><strong>@hust-twj</strong></a> 提供，详情查看：<a href="https://github.com/HuolalaTech/hll-wp-therouter-android/pull/184">https://github.com/HuolalaTech/hll-wp-therouter-android/pull/184</a></p>

<p>使用前，需要在<code class="language-plaintext highlighter-rouge">gradle.properties</code>内开启 KSP 的增量编译。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ksp.incremental=true
ksp.incremental.log=true
ksp.incremental.intermodule=true
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="ksp不再兼容agp4">KSP不再兼容AGP4</h2>

<p>由于使用了<code class="language-plaintext highlighter-rouge">1.9.21-1.0.16</code>版本的KSP（已经是能支持增量编译的最低版本），必须将Kotlin版本也升级到<code class="language-plaintext highlighter-rouge">1.9.21</code>，因此无法再兼容<code class="language-plaintext highlighter-rouge">AGP4</code>的编译。   <br />
推荐你采用项目demo一致的 Gradle 版本号和 AGP 版本号。</p>

<p>Gradle Version：<a href="https://github.com/HuolalaTech/hll-wp-therouter-android/blob/dev/gradle/wrapper/gradle-wrapper.properties">https://github.com/HuolalaTech/hll-wp-therouter-android/blob/dev/gradle/wrapper/gradle-wrapper.properties</a> <br />
AGP Version：<a href="https://github.com/HuolalaTech/hll-wp-therouter-android/blob/dev/build.gradle">https://github.com/HuolalaTech/hll-wp-therouter-android/blob/dev/build.gradle</a></p>

<p><br /></p>

<h2 id="agp8-编译提速">AGP8 编译提速</h2>

<p>老版本的 TheRouter 采用了 Gradle 标准 API，在插件内会将所有的 jar 和 class 聚合成一个，造成编译速度非常慢。</p>

<p>新版本采用了一个全新的方案，在标准 API 的基础上，最大幅度降低了编译耗时，但是首次编译或每次新增删除模块的时候，都需要重写构建一次。</p>

<p>详细方案请见：  <a href="https://kymjs.com/code/2024/10/31/01/">https://kymjs.com/code/2024/10/31/01/</a></p>

<p><br /></p>]]></content><author><name></name></author><category term="docs" /><category term="框架简介" /><summary type="html"><![CDATA[从`1.2.3-rc1`版本开始，我们对`TheRouter`编译过程做了大量优化，同时适配了`Gradle`的`4.x-8.x`全部版本，理论上更新的版本或更老的版本也能支持，只是没有去测试。]]></summary></entry><entry><title type="html">TheRouterSwift iOS 路由介绍</title><link href="http://localhost:4000/docs/2023/09/26/01" rel="alternate" type="text/html" title="TheRouterSwift iOS 路由介绍" /><published>2023-09-26T00:00:00+08:00</published><updated>2023-09-26T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/09/26/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/09/26/01"><![CDATA[<h2 id="背景">背景</h2>
<ol>
  <li>随着社区对支持Swift的需求日益增多，Swift5.0二进制库也具有更好的稳定性和兼容性表现，货拉拉技术团队根据社区反馈及内部讨论，决定开源内部业务使用的Swift版本路由组件，与2023年8月份已发布的Objective-C版本路由组件组成一个完整解决方案。</li>
  <li>TheRouter开源团队将把重心放在维护和升级Swift版本的TheRouter上。同时也会持续支持Objective-C版本的易用性，并欢迎社区贡献。</li>
  <li>对于使用Objective-C版本TheRouter的用户，建议将版本固定为1.0.0版以确保稳定性。
    <h2 id="features">Features</h2>
    <p>TheRouter一个用于模块间解耦和通信，基于Swift协议进行动态懒加载注册路由与打开路由的工具。同时支持通过Service-Protocol寻找对应的模块，并用 protocol进行依赖注入和模块通信。</p>
    <ul>
      <li><strong>1. 页面导航跳转能力</strong>：支持常规vc或Storyboard的push/present/popToTaget/windowNavRoot/modalDismissBeforePush跳转能力；</li>
      <li><strong>2. 路由自动注册能力</strong>：懒加载方式动态注册路由，仅当第一次调用OpenURL时进行动态注册；</li>
      <li><strong>3. 路由映射文件导出</strong>：支持将工程中的路由映射关系导出为文档，支持JSON、Plist格式，方便开发者进行双端的汇总比对、记录等；</li>
      <li><strong>4. 服务自动注册能力</strong>：动态注册服务，使用runtime方式自动注入；</li>
      <li><strong>5. 硬编码消除</strong>：将注册的path转为静态字符串常量供业务使用；</li>
      <li><strong>6. 动态化能力</strong>：支持添加重定向，移除重定向、动态添加路由、动态移除路由、拦截器、错误path修复等；</li>
      <li><strong>7. 链式编程</strong>：支持链式编程方式拼接URL与参数；</li>
      <li><strong>8. 适配Objective-C</strong>：OC类可以在Swift中使用继承的方式遵循协议来进行动态注册；</li>
      <li><strong>9. 服务调用</strong>：支持本地服务调用与远端服务调用；</li>
    </ul>
  </li>
</ol>

<p><img src="https://z1.ax1x.com/2023/09/26/pPHS4UO.png" class="blog-img" /></p>

<h1 id="背景-1">背景</h1>
<p>随着项目需求的日益增加，开发人员的不断增加，带来了很多问题：</p>

<ul>
  <li>
    <p>模块划分不清晰，任何开发人员随意调用并修改其他模块的代码实现以满足自己的业务需求。</p>
  </li>
  <li>
    <p>维护困难，同一组件的不同服务，散落在工程各个地方，不利于统一维护修改替换。</p>
  </li>
  <li>
    <p>模块负责人无法清晰，导致同一功能多人维护，造成冲突。</p>
  </li>
</ul>

<p>另外件拆分完之后都上升到远端，那么它们之间本地的代码是没办法相互依赖的，所以就需要通过一种工具，然后去实现透传服务的能力。我们需要一个中间件去处理这些问题。路由即是将耦合进行转移，通过增加中间层映射关系，解决业务之间的依赖关系。</p>

<h2 id="一个成熟的路由该是什么样子">一个成熟的路由该是什么样子</h2>

<p><strong>1.</strong>  业务组件化之后，组件化需要将整个项目的各个模块进行解耦，升级远端之后，界面之间的跳转怎么解决？<strong>路由 Api</strong></p>

<p><strong>2.</strong>  动态注册路由，无需手动注册。服务的动态注册，无需手动注册。</p>

<p><strong>3.</strong>  端上跳转统一问题怎么解决？<strong>使用统一 URL 映射方式处理</strong></p>

<p><strong>4.</strong>  业务跳转中出现问题，如何修改跳转逻辑？服务如何降级? <strong>远端下发配置，修改跳转 URL</strong></p>

<p><strong>5.</strong>  业务服务异常，界面改为 h5 界面。<strong>重定向</strong></p>

<p><strong>6.</strong>  App 跳转出现问题如何跳转到同一个本地的 error 界面？<strong>统一失败处理</strong></p>

<p><strong>7.</strong>  如何在跳转前增加强制的业务逻辑处理，比如业务调整，必须先执行某些操作，才能进入。<strong>重定向</strong></p>

<p><strong>8.</strong>  业务中有很多需要前置跳转，比如先登录才能去订单列表，如何实现。<strong>拦截器</strong></p>

<p><strong>9.</strong>  如何测试各个跳转业务是否正常。 <strong>路由 Path 校验</strong></p>

<p><strong>10.</strong> 如何把最频繁的业务跳转前置，减少查询次数？<strong>增加优先级 priority</strong></p>

<p><strong>11.</strong> 本地服务通过路由调用，远端服务通过路由调用 <strong>支持服务调用</strong></p>

<h2 id="整体设计思路">整体设计思路</h2>

<p>为了和Android端保持一致，使用了URL，class注册的方式实现。通过URL匹配方式查询数组中保存的模版信息，找到执行获取对应实例，执行跳转操作。</p>

<p><img src="https://z1.ax1x.com/2023/09/26/pP7zc0f.png" class="blog-img" /></p>

<h2 id="使用介绍预览">使用介绍预览</h2>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/therouter_ios1.gif" class="blog-img" /></p>

<h2 id="如何集成使用">如何集成使用</h2>

<h3 id="cocoapods">CocoaPods</h3>

<p>Add the following entry in your Podfile:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">pod</span> <span class="err">'</span><span class="nc">TheRouter</span><span class="err">'</span><span class="p">,</span> <span class="err">'</span><span class="mf">1.1.0</span><span class="err">'</span>
</code></pre></div></div>

<h2 id="swift限制版本">Swift限制版本</h2>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">Swift5</span><span class="mf">.0</span> <span class="n">or</span> <span class="n">above</span>
</code></pre></div></div>

<h2 id="therouter-使用方式">TheRouter 使用方式</h2>

<ol>
  <li>
    <h3 id="注册">注册</h3>
  </li>
</ol>

<p>鉴于已经实现了自动注册能力，开发者无需自己添加路由，只需要进行如下操作即可</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 实现TheRouterable协议</span>
<span class="n">extension</span> <span class="nc">TheRouterController</span><span class="p">:</span> <span class="nc">TheRouterable</span> <span class="p">{</span>
    
    <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="p">{</span>
<span class="na">        ["scheme://router/demo"]</span>
    <span class="p">}</span>
    
    <span class="n">static</span> <span class="n">func</span> <span class="nf">registerAction</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span> <span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nc">Any</span> <span class="p">{</span>
        <span class="nf">debugPrint</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        
        <span class="n">let</span> <span class="n">vc</span> <span class="p">=</span>  <span class="nc">TheRouterController</span><span class="p">()</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">qrResultCallBack</span> <span class="p">=</span> <span class="n">info</span><span class="p">[</span><span class="s">"clouse"</span><span class="p">]</span> <span class="k">as</span><span class="p">?</span> <span class="nc">QrScanResultCallBack</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">resultLabel</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">info</span><span class="p">.</span><span class="n">description</span>
        <span class="k">return</span> <span class="n">vc</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 在AppDelegate中实现懒加载的闭包</span>
<span class="c1">// 路由懒加载注册</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">lazyRegisterRouterHandle</span> <span class="p">{</span> <span class="n">url</span><span class="p">,</span> <span class="n">userInfo</span> <span class="k">in</span>
    <span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">injectRouterServiceConfig</span><span class="p">(</span><span class="n">webRouterUrl</span><span class="p">,</span> <span class="n">serivceHost</span><span class="p">)</span>
    <span class="k">return</span> <span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">addGloableRouter</span><span class="p">([</span><span class="s">".The"</span><span class="p">],</span> <span class="n">url</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 动态注册服务</span>
<span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">registerServices</span><span class="p">()</span>

<span class="c1">// 日志回调，可以监控线上路由运行情况</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">logcat</span> <span class="p">{</span> <span class="n">url</span><span class="p">,</span> <span class="n">logType</span><span class="p">,</span> <span class="n">errorMsg</span> <span class="k">in</span>
    <span class="nf">debugPrint</span><span class="p">(</span><span class="s">"TheRouter: logMsg- \(url) \(logType.rawValue) \(errorMsg)"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="oc-注解的形式">OC 注解的形式</h4>

<p>这里列举了OC使用注解的方式，Swift因为其缺乏动态性，是不支持注解的。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用注解</span>
<span class="err">@</span><span class="nf">page</span><span class="p">(</span><span class="s">@"home/main"</span><span class="p">)</span>
<span class="p">-</span> <span class="p">(</span><span class="nc">UIViewController</span> <span class="p">*)</span><span class="nf">homePage</span><span class="p">{</span>
    <span class="c1">// Do stuff...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="swift-注册形式">Swift 注册形式</h4>

<p>Swift 中，我们都知道 Swift 是不支持注解的，那么 Swift 动态注册路由该怎么解决呢，我们使用 runtime 遍历工程里的方式找到遵循了路由协议的类进行自动注册。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kd">class</span> <span class="err">func register</span><span class="nc">RouterMap</span><span class="p">(</span><span class="n">_</span> <span class="n">registerClassPrifxArray</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">],</span> <span class="n">_</span> <span class="n">urlPath</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">_</span> <span class="n">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
        
        <span class="n">let</span> <span class="n">expectedClassCount</span> <span class="p">=</span> <span class="nf">objc_getClassList</span><span class="p">(</span><span class="n">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">let</span> <span class="n">allClasses</span> <span class="p">=</span> <span class="nc">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="nc">AnyClass</span><span class="p">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nc">Int</span><span class="p">(</span><span class="n">expectedClassCount</span><span class="p">))</span>
        <span class="n">let</span> <span class="n">autoreleasingAllClasses</span> <span class="p">=</span> <span class="nc">AutoreleasingUnsafeMutablePointer</span><span class="p">&lt;</span><span class="nc">AnyClass</span><span class="p">&gt;(</span><span class="n">allClasses</span><span class="p">)</span>
        <span class="n">let</span> <span class="n">actualClassCount</span><span class="p">:</span> <span class="nc">Int32</span> <span class="p">=</span> <span class="nf">objc_getClassList</span><span class="p">(</span><span class="n">autoreleasingAllClasses</span><span class="p">,</span> <span class="n">expectedClassCount</span><span class="p">)</span>
        
        <span class="kd">var</span> <span class="py">resultXLClass</span> <span class="p">=</span> <span class="p">[</span><span class="nc">AnyClass</span><span class="p">]()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span><span class="p">&lt;</span> <span class="nf">actualClassCount</span> <span class="p">{</span>
            
            <span class="n">let</span> <span class="n">currentClass</span><span class="p">:</span> <span class="nc">AnyClass</span> <span class="p">=</span> <span class="n">allClasses</span><span class="p">[</span><span class="nc">Int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
            <span class="n">let</span> <span class="n">fullClassName</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="nc">NSStringFromClass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">.</span><span class="n">self</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="nf">registerClassPrifxArray</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fullClassName</span><span class="p">.</span><span class="nf">containsSubString</span><span class="p">(</span><span class="n">substring</span><span class="p">:</span> <span class="n">value</span><span class="p">))</span>  <span class="p">{</span>
                    <span class="k">if</span> <span class="n">currentClass</span> <span class="k">is</span> <span class="nc">UIViewController</span><span class="p">.</span><span class="nc">Type</span> <span class="p">{</span>
                        <span class="n">resultXLClass</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)</span>
                    <span class="p">}</span>
                    
    <span class="err">#</span><span class="k">if</span> <span class="nc">DEBUG</span>
                    <span class="k">if</span> <span class="n">let</span> <span class="n">clss</span> <span class="p">=</span> <span class="n">currentClass</span> <span class="k">as</span><span class="p">?</span> <span class="nc">CustomRouterInfo</span><span class="p">.</span><span class="nc">Type</span> <span class="p">{</span>
                        <span class="nf">assert</span><span class="p">(</span><span class="n">clss</span><span class="p">.</span><span class="n">patternString</span><span class="p">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"scheme://"</span><span class="p">),</span> <span class="s">"URL非scheme://开头，请重新确认"</span><span class="p">)</span>
                        <span class="n">apiArray</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">clss</span><span class="p">.</span><span class="n">patternString</span><span class="p">)</span>
                        <span class="n">classMapArray</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">clss</span><span class="p">.</span><span class="n">routerClass</span><span class="p">)</span>
                    <span class="p">}</span>
    <span class="err">#</span><span class="n">endif</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span><span class="p">&lt;</span> <span class="n">resultXLClass</span><span class="p">.</span><span class="nf">count</span> <span class="p">{</span>
            <span class="n">let</span> <span class="n">currentClass</span><span class="p">:</span> <span class="nc">AnyClass</span> <span class="p">=</span> <span class="n">resultXLClass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">let</span> <span class="n">cls</span> <span class="p">=</span> <span class="n">currentClass</span> <span class="k">as</span><span class="p">?</span> <span class="nc">TheRouterable</span><span class="p">.</span><span class="nc">Type</span> <span class="p">{</span>
                <span class="n">let</span> <span class="n">fullName</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="nc">NSStringFromClass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">.</span><span class="n">self</span><span class="p">)</span>
               
                <span class="k">for</span> <span class="n">s</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span><span class="p">&lt;</span> <span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">.</span><span class="nf">count</span> <span class="p">{</span>
                    
                    <span class="k">if</span> <span class="n">fullName</span><span class="p">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="nc">NSKVONotifyingPrefix</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">let</span> <span class="n">range</span> <span class="p">=</span> <span class="n">fullName</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">fullName</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="nc">NSKVONotifyingPrefix</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">..</span><span class="p">&lt;</span><span class="n">fullName</span><span class="p">.</span><span class="n">endIndex</span>
                        <span class="n">let</span> <span class="n">subString</span> <span class="p">=</span> <span class="n">fullName</span><span class="p">[</span><span class="n">range</span><span class="p">]</span>
                        <span class="n">pagePathMap</span><span class="p">[</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="p">=</span> <span class="s">"\(subString)"</span>
                        <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">classString</span><span class="p">:</span> <span class="s">"\(subString)"</span><span class="p">)</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">pagePathMap</span><span class="p">[</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="p">=</span> <span class="n">fullName</span>
                        <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">classString</span><span class="p">:</span> <span class="n">fullName</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
<span class="err">#</span><span class="k">if</span> <span class="nc">DEBUG</span>
        <span class="nf">debugPrint</span><span class="p">(</span><span class="n">pagePathMap</span><span class="p">)</span>
        <span class="nf">routerForceRecheck</span><span class="p">()</span>
<span class="err">#</span><span class="n">endif</span>
        <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">routerLoadStatus</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="n">urlPath</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">:</span> <span class="n">userInfo</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了避免无效遍历，我们通过传入 registerClassPrifxArray 指定我们遍历包含这些前缀的类即可。一旦是 UIViewController.Type 类型就进行存储，然后再进行校验是否遵循 TheRouterable 协议，遵循则自动注册。无需手动注册。</p>

<h4 id="路由注册的懒加载">路由注册的懒加载</h4>

<p>采用动态注册有一个不好的情况就是在启动时就去动态注册，在 TheRouter 中注册的时机被延后了，放在了 App 第一次通过 TheRouter.openUrl()时进行注册，会判断路由是否加载完毕，未加载完毕进行加载，然后打开路由。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">@</span><span class="n">discardableResult</span>
<span class="k">public</span> <span class="kd">class</span> <span class="err">func open</span><span class="nc">URL</span><span class="p">(</span><span class="n">_</span> <span class="n">urlString</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">](),</span> <span class="n">handler</span><span class="p">:</span> <span class="n">complateHandler</span> <span class="p">=</span> <span class="n">nil</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">urlString</span><span class="p">.</span><span class="nf">isEmpty</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="n">shareInstance</span><span class="p">.</span><span class="nf">isLoaded</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">shareInstance</span><span class="p">.</span><span class="n">lazyRegisterHandleBlock</span><span class="p">?(</span><span class="n">urlString</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nf">openCacheRouter</span><span class="p">((</span><span class="n">urlString</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - Public method</span>
<span class="err">@</span><span class="n">discardableResult</span>
<span class="k">public</span> <span class="kd">class</span> <span class="err">func open</span><span class="nc">URL</span><span class="p">(</span><span class="n">_</span> <span class="n">uriTuple</span><span class="p">:</span> <span class="p">(</span><span class="nc">String</span><span class="p">,</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]),</span> <span class="n">handler</span><span class="p">:</span> <span class="n">complateHandler</span> <span class="p">=</span> <span class="n">nil</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="n">shareInstance</span><span class="p">.</span><span class="nf">isLoaded</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">shareInstance</span><span class="p">.</span><span class="n">lazyRegisterHandleBlock</span><span class="p">?(</span><span class="n">uriTuple</span><span class="mf">.0</span><span class="p">,</span> <span class="n">uriTuple</span><span class="mf">.1</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">openCacheRouter</span><span class="p">(</span><span class="n">uriTuple</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="kd">class</span> <span class="err">func open</span><span class="nc">CacheRouter</span><span class="p">(</span><span class="n">_</span> <span class="n">uriTuple</span><span class="p">:</span> <span class="p">(</span><span class="nc">String</span><span class="p">,</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]),</span> <span class="n">handler</span><span class="p">:</span> <span class="n">complateHandler</span> <span class="p">=</span> <span class="n">nil</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>

    <span class="k">if</span> <span class="n">uriTuple</span><span class="mf">.0</span><span class="p">.</span><span class="nf">isEmpty</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">uriTuple</span><span class="mf">.0</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">shareInstance</span><span class="p">.</span><span class="n">serviceHost</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">routerService</span><span class="p">(</span><span class="n">uriTuple</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">routerJump</span><span class="p">(</span><span class="n">uriTuple</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="如何让-oc-类也享受到-swift-路由">如何让 OC 类也享受到 Swift 路由</h4>

<p>这是一个 OC 类的界面，实现路由的跳转需要继承 OC 类，并实现 TheRouterAble 协议即可</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">@</span><span class="kd">interface</span> <span class="nc">TheRouterBController</span> <span class="p">:</span> <span class="nc">UIViewController</span>
<span class="err">@</span><span class="nf">property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="nc">UILabel</span> <span class="p">*</span><span class="n">desLabel</span><span class="p">;</span>
<span class="err">@</span><span class="n">end</span>

<span class="err">@</span><span class="kd">interface</span> <span class="nc">TheRouterBController</span> <span class="p">()</span>

<span class="err">@</span><span class="n">end</span>

<span class="err">@</span><span class="n">implementation</span> <span class="nc">TheRouterBController</span>

<span class="p">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
<span class="na">    [super viewDidLoad]</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">[</span><span class="nc">UIColor</span> <span class="n">yellowColor</span><span class="p">];</span>
<span class="na">    [self.view addSubview:self.desLabel]</span><span class="p">;</span>
    <span class="c1">// Do any additional setup after loading the view.</span>
<span class="p">}</span>
<span class="err">@</span><span class="n">end</span>

<span class="k">public</span> <span class="kd">class</span> <span class="nc">TheRouterControllerB</span><span class="p">:</span> <span class="nc">TheRouterBController</span><span class="p">,</span> <span class="nc">TheRouterable</span> <span class="p">{</span>

    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="p">[</span><span class="s">"scheme://router/demo2"</span><span class="p">,</span>
         <span class="s">"scheme://router/demo2-Android"</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">descriptions</span><span class="p">:</span> <span class="nc">String</span> <span class="p">{</span>
        <span class="s">"TheRouterControllerDemo"</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">static</span> <span class="n">func</span> <span class="nf">registerAction</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span> <span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nc">Any</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">vc</span> <span class="p">=</span>  <span class="nc">TheRouterBController</span><span class="p">()</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">desLabel</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">info</span><span class="p">.</span><span class="n">description</span>
        <span class="k">return</span> <span class="n">vc</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="同时支持手动单个注册">同时支持手动单个注册</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 模型模式</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="nc">RouteItem</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="s">"scheme://router/demo?&amp;desc=简单注册,直接调用TheRouter.addRouterItem()注册即可"</span><span class="p">,</span> <span class="n">className</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterController"</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="s">"简单注册,直接调用TheRouter"</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="p">[</span><span class="s">"key1"</span><span class="p">:</span> <span class="mi">1</span><span class="p">]))</span>
<span class="c1">// 字典模式</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">([</span><span class="s">"scheme://router/demo?&amp;desc=简单注册,直接调用TheRouter.addRouterItem()注册即可"</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterController"</span><span class="p">])</span>
<span class="c1">// 常量参数模式</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="s">"scheme://router/demo?&amp;desc=简单注册"</span><span class="p">,</span> <span class="n">classString</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterController"</span><span class="p">)</span>
<span class="c1">// 协议模式， TheRouterApi实现了 CustomRouterInfo协议</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="nc">TheRouterApi</span><span class="p">.</span><span class="n">patternString</span><span class="p">,</span> <span class="n">classString</span><span class="p">:</span> <span class="nc">TheRouterApi</span><span class="p">.</span><span class="n">routerClass</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="同时支持手动批量注册">同时支持手动批量注册</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">([</span><span class="s">"scheme://router/demo"</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterController"</span><span class="p">,</span>
                    <span class="s">"scheme://router/demo1"</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterControllerA"</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="移除">移除</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span><span class="p">.</span><span class="nf">removeRouter</span><span class="p">(</span><span class="nc">TheRouterViewCApi</span><span class="p">.</span><span class="n">patternString</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="打开">打开</h3>

<p>声明了不同的方法，主要用于明显的区分，内部统一调用 openURL</p>

<p>便利构造器链式打开路由</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">model</span> <span class="p">=</span> <span class="nc">TheRouterModel</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">"AKyS"</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">18</span><span class="p">)</span>
<span class="nc">TheRouterBuilder</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="s">"scheme://router/demo"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withInt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"intValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withString</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"stringValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s">"2222"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withFloat</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"floatValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mf">3.1415</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withBool</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"boolValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withDouble</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"doubleValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">withAny</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"any"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">navigation</span><span class="p">()</span>
    
<span class="nc">TheRouterBuilder</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="s">"scheme://router/demo"</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withInt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"intValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withString</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"stringValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s">"sdsd"</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withFloat</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"floatValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mf">3.1415</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withBool</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"boolValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="k">false</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withDouble</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"doubleValue"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">withAny</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">"any"</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
	<span class="p">.</span><span class="nf">navigation</span> <span class="p">{</span> <span class="n">params</span><span class="p">,</span> <span class="n">instance</span> <span class="k">in</span>
	    
	<span class="p">}</span>
    
</code></pre></div></div>

<p>打开路由常用方式</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kd">class</span> <span class="nc">TheRouterApi</span><span class="p">:</span> <span class="nc">CustomRouterInfo</span> <span class="p">{</span>

    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span> <span class="p">=</span> <span class="s">"scheme://router/demo"</span>
    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">routerClass</span> <span class="p">=</span> <span class="s">"TheRouter_Example.TheRouterController"</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">params</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[:]</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">jumpType</span><span class="p">:</span> <span class="nc">LAJumpType</span> <span class="p">=</span> <span class="p">.</span><span class="n">push</span>

    <span class="k">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="kd">class</span> <span class="nc">TheRouterAApi</span><span class="p">:</span> <span class="nc">CustomRouterInfo</span> <span class="p">{</span>

    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span> <span class="p">=</span> <span class="s">"scheme://router/demo1"</span>
    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">routerClass</span> <span class="p">=</span> <span class="s">"TheRouter_Example.TheRouterControllerA"</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">params</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[:]</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">jumpType</span><span class="p">:</span> <span class="nc">LAJumpType</span> <span class="p">=</span> <span class="p">.</span><span class="n">push</span>

    <span class="k">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="nc">TheRouterCApi</span><span class="p">.</span><span class="nf">init</span><span class="p">().</span><span class="n">requiredURL</span><span class="p">)</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openWebURL</span><span class="p">(</span><span class="s">"https://xxxxxxxx"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="err">@</span><span class="n">discardableResult</span>
<span class="k">public</span> <span class="kd">class</span> <span class="err">func open</span><span class="nc">WebURL</span><span class="p">(</span><span class="n">_</span> <span class="n">uriTuple</span><span class="p">:</span> <span class="p">(</span><span class="nc">String</span><span class="p">,</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]))</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="n">uriTuple</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">@</span><span class="n">discardableResult</span>
<span class="k">public</span> <span class="kd">class</span> <span class="err">func open</span><span class="nc">WebURL</span><span class="p">(</span><span class="n">_</span> <span class="n">urlString</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span>
                             <span class="n">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]())</span> <span class="p">-&gt;</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
    <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">((</span><span class="n">urlString</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>元祖形式传入路由与追加参数</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">((</span><span class="s">"scheme://router/demo1?id=2&amp;value=3&amp;name=AKyS&amp;desc=直接调用TheRouter.addRouterItem()注册即可，支持单个注册，批量注册，动态注册，懒加载动态注册"</span><span class="p">,</span> <span class="p">[</span><span class="s">"descs"</span><span class="p">:</span> <span class="s">"追加参数"</span><span class="p">]))</span>
</code></pre></div></div>

<p>参数传递方式</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">clouse</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">qrResult</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">qrStatus</span><span class="p">:</span> <span class="nc">Bool</span><span class="p">)</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"\(qrResult) \(qrStatus)"</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="nf">makeToast</span><span class="p">(</span><span class="s">"\(qrResult) \(qrStatus)"</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">let</span> <span class="n">model</span> <span class="p">=</span> <span class="nc">TheRouterModel</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">"AKyS"</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">18</span><span class="p">)</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">((</span><span class="s">"scheme://router/demo?id=2&amp;value=3&amp;name=AKyS"</span><span class="p">,</span> <span class="p">[</span><span class="s">"model"</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span> <span class="s">"clouse"</span><span class="p">:</span> <span class="n">clouse</span><span class="p">]))</span>
</code></pre></div></div>

<h3 id="全局失败映射">全局失败映射</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span><span class="p">.</span><span class="nf">globalOpenFailedHandler</span> <span class="p">{</span> <span class="n">info</span> <span class="k">in</span>
   <span class="nf">debugPrint</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="拦截">拦截</h3>

<p>比如在未登录情况下统一拦截：跳转消息列表之前先去登录，登录成功之后跳转到消息列表等。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">login</span> <span class="p">=</span> <span class="nc">TheRouterLoginApi</span><span class="p">.</span><span class="n">templateString</span>
 <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterInterceptor</span><span class="p">([</span><span class="n">login</span><span class="p">],</span> <span class="n">priority</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nc">Bool</span> <span class="k">in</span>
       <span class="k">if</span> <span class="nc">LALoginManger</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="nf">isLogin</span> <span class="p">{</span>
             <span class="k">return</span> <span class="k">true</span>
       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
             <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="nc">TheRouterLoginApi</span><span class="p">().</span><span class="n">build</span><span class="p">)</span>
             <span class="k">return</span> <span class="k">false</span>
       <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>登录成功之后删除拦截器即可。</p>

<h3 id="路由-path-与类正确安全校验">路由 Path 与类正确安全校验</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 客户端强制校验，是否匹配</span>
<span class="k">public</span> <span class="n">static</span> <span class="n">func</span> <span class="nf">routerForceRecheck</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">patternArray</span> <span class="p">=</span> <span class="nc">Set</span><span class="p">(</span><span class="n">pagePathMap</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">apiPathArray</span> <span class="p">=</span> <span class="nc">Set</span><span class="p">(</span><span class="n">apiArray</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">diffArray</span> <span class="p">=</span> <span class="n">patternArray</span><span class="p">.</span><span class="nf">symmetricDifference</span><span class="p">(</span><span class="n">apiPathArray</span><span class="p">)</span>
    <span class="nf">debugPrint</span><span class="p">(</span><span class="s">"URL差集：\(diffArray)"</span><span class="p">)</span>
    <span class="nf">debugPrint</span><span class="p">(</span><span class="s">"pagePathMap：\(pagePathMap)"</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="n">diffArray</span><span class="p">.</span><span class="n">count</span> <span class="p">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"URL 拼写错误，请确认差集中的url是否匹配"</span><span class="p">)</span>

    <span class="n">let</span> <span class="n">patternValueArray</span> <span class="p">=</span> <span class="nc">Set</span><span class="p">(</span><span class="n">pagePathMap</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">classPathArray</span> <span class="p">=</span> <span class="nc">Set</span><span class="p">(</span><span class="n">classMapArray</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">diffClassesArray</span> <span class="p">=</span> <span class="n">patternValueArray</span><span class="p">.</span><span class="nf">symmetricDifference</span><span class="p">(</span><span class="n">classPathArray</span><span class="p">)</span>
    <span class="nf">debugPrint</span><span class="p">(</span><span class="s">"classes差集：\(diffClassesArray)"</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="n">diffClassesArray</span><span class="p">.</span><span class="n">count</span> <span class="p">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"classes 拼写错误，请确认差集中的class是否匹配"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="踩坑路由注册-kvo">踩坑路由注册-KVO</h3>

<p>在进行 classes 本地校验时遇到了类名不匹配问题。</p>

<p>排查原因： 是因为为了避免路由在启动时就注册，影响启动速度，采用了懒加载的方式即第一次打开路由界面的时候才先进行注册然后跳转。但是在我们动态注册之前，某个类因为添加了 KVO (Key-Value Observing 键值监听)，这个类在遍历时 className 修改为了 NSKVONotifying_xxx。需要我们进行特殊处理，如下</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 对于KVO监听，动态创建子类，需要特殊处理</span>
<span class="k">public</span> <span class="n">let</span> <span class="nc">NSKVONotifyingPrefix</span> <span class="p">=</span> <span class="s">"NSKVONotifying_"</span>

<span class="k">if</span> <span class="n">fullName</span><span class="p">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="nc">NSKVONotifyingPrefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">range</span> <span class="p">=</span> <span class="n">fullName</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">fullName</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="nc">NSKVONotifyingPrefix</span><span class="p">.</span><span class="n">count</span><span class="p">)</span><span class="o">..</span><span class="p">&lt;</span><span class="n">fullName</span><span class="p">.</span><span class="n">endIndex</span>
    <span class="n">let</span> <span class="n">subString</span> <span class="p">=</span> <span class="n">fullName</span><span class="p">[</span><span class="n">range</span><span class="p">]</span>
    <span class="n">pagePathMap</span><span class="p">[</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="p">=</span> <span class="s">"\(subString)"</span>
    <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">addRouterItem</span><span class="p">(</span><span class="n">cls</span><span class="p">.</span><span class="n">patternString</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">classString</span><span class="p">:</span> <span class="s">"\(subString)"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="动态调用路由">动态调用路由</h2>

<p>在之上的路由能力下，我们希望 App 能够支持动态增加路由，删除路由，重定向路由、通过路由调起本地服务、远端通过路由调起 App 服务能力，随即进行了动态化的扩展。</p>

<h3 id="重定向功能">重定向功能</h3>
<p>定义路由下发模型数据结构</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">struct</span> <span class="nc">TheRouterInfo</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
    
    <span class="k">public</span> <span class="kd">var</span> <span class="py">targetPath</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">""</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">orginPath</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">""</span>
    <span class="c1">// 1: 表示替换或者修复客户端代码path错误 2: 新增路由path 3:删除路由</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">routerType</span><span class="p">:</span> <span class="nc">TheRouterReloadMapEnum</span> <span class="p">=</span> <span class="p">.</span><span class="n">none</span> 
    <span class="k">public</span> <span class="kd">var</span> <span class="py">path</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">""</span> <span class="c1">// 新的路由地址</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">className</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">""</span> <span class="c1">// 路由地址对应的界面</span>
    <span class="k">public</span> <span class="kd">var</span> <span class="py">params</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">]</span> <span class="p">=</span> <span class="p">[:]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过远端下发重定向数据，原本跳转到白色界面的业务逻辑改为跳转到黄色界面</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">relocationMap</span> <span class="p">=</span> <span class="p">[</span><span class="s">"routerType"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"targetPath"</span><span class="p">:</span> <span class="s">"scheme://router/demo1"</span><span class="p">,</span> <span class="s">"orginPath"</span><span class="p">:</span> <span class="s">"scheme://router/demo"</span><span class="p">]</span> <span class="k">as</span> <span class="nc">NSDictionary</span>
<span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">addRelocationHandle</span><span class="p">(</span><span class="n">routerMapList</span><span class="p">:</span> <span class="p">[</span><span class="n">relocationMap</span><span class="p">])</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="s">"scheme://router/demo?desc=跳转白色界面被重定向到了黄色界面"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="重定向恢复">重定向恢复</h3>

<p>在业务中，通常会进行业务调整，那么重定向之后需要恢复的话，就需要移除重定向</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">relocationMap</span> <span class="p">=</span> <span class="p">[</span><span class="s">"routerType"</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"targetPath"</span><span class="p">:</span> <span class="s">"scheme://router/demo"</span><span class="p">,</span> <span class="s">"orginPath"</span><span class="p">:</span> <span class="s">"scheme://router/demo"</span><span class="p">]</span> <span class="k">as</span> <span class="nc">NSDictionary</span>
<span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">addRelocationHandle</span><span class="p">(</span><span class="n">routerMapList</span><span class="p">:</span> <span class="p">[</span><span class="n">relocationMap</span><span class="p">])</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="s">"scheme://router/demo?desc=跳转白色界面被重定向到了黄色界面之后，根据下发数据又恢复到跳转白色界面"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="路由-path-动态修复">路由 Path 动态修复</h3>

<p>在实际开发中，开发人员因为马虎写错了路由 Path，上线之后无法进行正常的业务跳转，此时就需要通过远端下发路由进行匹配跳转了。scheme://router/demo3 是正确 path,但是本地写错的路由 path 为 scheme://router/demo33，那么需要新增一个 path 进行映射。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">relocationMap</span> <span class="p">=</span> <span class="p">[</span><span class="s">"routerType"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"className"</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterControllerC"</span><span class="p">,</span> <span class="s">"path"</span><span class="p">:</span> <span class="s">"scheme://router/demo33"</span><span class="p">]</span> <span class="k">as</span> <span class="nc">NSDictionary</span>
<span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">addRelocationHandle</span><span class="p">(</span><span class="n">routerMapList</span><span class="p">:</span> <span class="p">[</span><span class="n">relocationMap</span><span class="p">])</span>
<span class="n">let</span> <span class="n">value</span> <span class="p">=</span> <span class="nc">TheRouterCApi</span><span class="p">.</span><span class="nf">init</span><span class="p">().</span><span class="n">requiredURL</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="路由适配不同的-android-path">路由适配不同的 Android-Path</h3>

<p>在实际开发中，一旦使用 URI 这种方式，牵扯到双端，就可以存在双端不一致的问题，那么如何解决呢，可以通过本地新增多路由 path 解决，也可以通过远端下发新路由解决。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kd">class</span> <span class="nc">TheRouterControllerB</span><span class="p">:</span> <span class="nc">TheRouterBController</span><span class="p">,</span> <span class="nc">TheRouterable</span> <span class="p">{</span>

    <span class="k">public</span> <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="p">[</span><span class="s">"scheme://router/demo2"</span><span class="p">,</span>
         <span class="s">"scheme://router/demo2Android"</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">static</span> <span class="n">func</span> <span class="nf">registerAction</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span> <span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nc">Any</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">vc</span> <span class="p">=</span>  <span class="nc">TheRouterBController</span><span class="p">()</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">desLabel</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">info</span><span class="p">.</span><span class="n">description</span>
        <span class="k">return</span> <span class="n">vc</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">relocationMap</span> <span class="p">=</span> <span class="p">[</span><span class="s">"routerType"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"className"</span><span class="p">:</span> <span class="s">"TheRouter_Example.TheRouterControllerD"</span><span class="p">,</span> <span class="s">"path"</span><span class="p">:</span> <span class="s">"scheme://router/demo5"</span><span class="p">]</span> <span class="k">as</span> <span class="nc">NSDictionary</span>
<span class="nc">TheRouterManager</span><span class="p">.</span><span class="nf">addRelocationHandle</span><span class="p">(</span><span class="n">routerMapList</span><span class="p">:</span> <span class="p">[</span><span class="n">relocationMap</span><span class="p">])</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">(</span><span class="s">"scheme://router/demo2Android?desc=demo5是Android一个界面的path,为了双端统一，我们动态增加一个path,这样远端下发时demo5也就能跳转了"</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="服务的动态注册与调用">服务的动态注册与调用</h2>

<h3 id="如何声明服务及实现服务">如何声明服务及实现服务</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">@</span><span class="n">objc</span>
<span class="k">public</span> <span class="n">protocol</span> <span class="nc">AppConfigServiceProtocol</span><span class="p">:</span> <span class="nc">TheRouterServiceProtocol</span> <span class="p">{</span>
    <span class="c1">// 打开小程序</span>
    <span class="n">func</span> <span class="nf">openMiniProgram</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">:</span> <span class="nc">Any</span><span class="p">])</span>
<span class="p">}</span>

<span class="k">final</span> <span class="kd">class</span> <span class="nc">ConfigModuleService</span><span class="p">:</span> <span class="nc">NSObject</span><span class="p">,</span> <span class="nc">AppConfigServiceProtocol</span> <span class="p">{</span>
    
    <span class="n">static</span> <span class="kd">var</span> <span class="py">seriverName</span><span class="p">:</span> <span class="nc">String</span> <span class="p">{</span>
        <span class="nc">String</span><span class="p">(</span><span class="n">describing</span><span class="p">:</span> <span class="nc">AppConfigServiceProtocol</span><span class="p">.</span><span class="n">self</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">func</span> <span class="nf">openMiniProgram</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span> <span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">let</span> <span class="n">window</span> <span class="p">=</span> <span class="nc">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">delegate</span><span class="o">?.</span><span class="nf">window</span> <span class="p">{</span>
            <span class="n">window</span><span class="o">?.</span><span class="nf">makeToast</span><span class="p">(</span><span class="s">"打开微信小程序"</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">window</span><span class="o">?.</span><span class="n">center</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


</code></pre></div></div>
<h3 id="如何使用服务">如何使用服务</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 使用方式</span>
 <span class="k">if</span> <span class="n">let</span> <span class="n">appConfigService</span> <span class="p">=</span> <span class="nc">TheRouter</span><span class="p">.</span><span class="nf">fetchService</span><span class="p">(</span><span class="nc">AppConfigServiceProtocol</span><span class="p">.</span><span class="n">self</span><span class="p">){</span>
     <span class="n">appConfigService</span><span class="p">.</span><span class="nf">openMiniProgram</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[:])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>服务使用了runtime动态注册，所以你不用担心服务没有注册的问题。只需像上述案例一样使用即可。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kd">class</span> <span class="err">func register</span><span class="nc">Services</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">let</span> <span class="n">expectedClassCount</span> <span class="p">=</span> <span class="nf">objc_getClassList</span><span class="p">(</span><span class="n">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">allClasses</span> <span class="p">=</span> <span class="nc">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="nc">AnyClass</span><span class="p">&gt;.</span><span class="nf">allocate</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nc">Int</span><span class="p">(</span><span class="n">expectedClassCount</span><span class="p">))</span>
    <span class="n">let</span> <span class="n">autoreleasingAllClasses</span> <span class="p">=</span> <span class="nc">AutoreleasingUnsafeMutablePointer</span><span class="p">&lt;</span><span class="nc">AnyClass</span><span class="p">&gt;(</span><span class="n">allClasses</span><span class="p">)</span>
    <span class="n">let</span> <span class="n">actualClassCount</span><span class="p">:</span> <span class="nc">Int32</span> <span class="p">=</span> <span class="nf">objc_getClassList</span><span class="p">(</span><span class="n">autoreleasingAllClasses</span><span class="p">,</span> <span class="n">expectedClassCount</span><span class="p">)</span>
    <span class="kd">var</span> <span class="py">resultXLClass</span> <span class="p">=</span> <span class="p">[</span><span class="nc">AnyClass</span><span class="p">]()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span><span class="p">&lt;</span> <span class="nf">actualClassCount</span> <span class="p">{</span>
        
        <span class="n">let</span> <span class="n">currentClass</span><span class="p">:</span> <span class="nc">AnyClass</span> <span class="p">=</span> <span class="n">allClasses</span><span class="p">[</span><span class="nc">Int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">class_getInstanceMethod</span><span class="p">(</span><span class="n">currentClass</span><span class="p">,</span> <span class="nc">NSSelectorFromString</span><span class="p">(</span><span class="s">"methodSignatureForSelector:"</span><span class="p">))</span> <span class="p">!=</span> <span class="n">nil</span><span class="p">),</span>
           <span class="p">(</span><span class="nf">class_getInstanceMethod</span><span class="p">(</span><span class="n">currentClass</span><span class="p">,</span> <span class="nc">NSSelectorFromString</span><span class="p">(</span><span class="s">"doesNotRecognizeSelector:"</span><span class="p">))</span> <span class="p">!=</span> <span class="n">nil</span><span class="p">),</span>
           <span class="n">let</span> <span class="n">cls</span> <span class="p">=</span> <span class="n">currentClass</span> <span class="k">as</span><span class="p">?</span> <span class="nc">TheRouterServiceProtocol</span><span class="p">.</span><span class="nc">Type</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)</span>
            <span class="n">resultXLClass</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            
            <span class="nc">TheRouterServiceManager</span><span class="p">.</span><span class="n">default</span><span class="p">.</span><span class="nf">registerService</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="n">cls</span><span class="p">.</span><span class="n">seriverName</span><span class="p">,</span> <span class="n">lazyCreator</span><span class="p">:</span> <span class="p">(</span><span class="n">cls</span> <span class="k">as</span><span class="p">!</span> <span class="nc">NSObject</span><span class="p">.</span><span class="nc">Type</span><span class="p">).</span><span class="nf">init</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="路由远端调用本地服务服务接口下发mqttjsbridge">路由远端调用本地服务：服务接口下发，MQTT,JSBridge</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">dict</span> <span class="p">=</span> <span class="p">[</span><span class="s">"ivar1"</span><span class="p">:</span> <span class="p">[</span><span class="s">"key"</span><span class="p">:</span><span class="s">"value"</span><span class="p">]]</span>
<span class="n">let</span> <span class="n">url</span> <span class="p">=</span> <span class="s">"scheme://services?protocol=AppConfigLAServiceProtocol&amp;method=openMiniProgramWithInfo:&amp;resultType=0"</span>
<span class="nc">TheRouter</span><span class="p">.</span><span class="nf">openURL</span><span class="p">((</span><span class="n">url</span><span class="p">,</span> <span class="n">dict</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="是否考虑swift59-macros">是否考虑Swift5.9 Macros？</h2>

<p>从目前的实现方式来看，懒加载加上动态注册，已经解决了注册时的性能问题。即使需要遍历全工程的类，然后处理相关逻辑，也不会超过0.2s。之所以能够通过Class取得path，因为给类声明了静态变量。</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 实现TheRouterable协议</span>
<span class="n">extension</span> <span class="nc">TheRouterController</span><span class="p">:</span> <span class="nc">TheRouterable</span> <span class="p">{</span>
    
    <span class="n">static</span> <span class="kd">var</span> <span class="py">patternString</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="p">{</span>
<span class="na">        ["scheme://router/demo"]</span>
    <span class="p">}</span>
    
    <span class="n">static</span> <span class="n">func</span> <span class="nf">registerAction</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="p">[</span><span class="nc">String</span> <span class="p">:</span> <span class="nc">Any</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nc">Any</span> <span class="p">{</span>
        <span class="nf">debugPrint</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        
        <span class="n">let</span> <span class="n">vc</span> <span class="p">=</span>  <span class="nc">TheRouterController</span><span class="p">()</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">qrResultCallBack</span> <span class="p">=</span> <span class="n">info</span><span class="p">[</span><span class="s">"clouse"</span><span class="p">]</span> <span class="k">as</span><span class="p">?</span> <span class="nc">QrScanResultCallBack</span>
        <span class="n">vc</span><span class="p">.</span><span class="n">resultLabel</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">info</span><span class="p">.</span><span class="n">description</span>
        <span class="k">return</span> <span class="n">vc</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="关于作者">关于作者</h2>

<p><a href="https://juejin.cn/user/1768489241815070">货拉拉移动端技术团队</a></p>

<h2 id="开源协议">开源协议</h2>

<p>TheRouter 采用Apache2.0协议，详情参考<a href="LICENSE">LICENSE</a></p>

<h2 id="交流沟通群">交流沟通群</h2>
<p><img src="https://cdn.kymjs.com:8843/therouter_assets/wx/wx_ios_group.jpg" class="blog-img" /></p>]]></content><author><name></name></author><category term="docs" /><category term="框架简介" /><summary type="html"><![CDATA[TheRouterSwift是货拉拉TheRouter系列开源框架的Swift版本，为日益增多的Swift开发者提供一高可用路由框架。TheRouterSwift用于模块间解耦和通信，基于Swift协议进行动态懒加载注册路由与打开路由的工具。同时支持通过Service-Protocol寻找对应的模块，并用 protocol进行依赖注入和模块通信。]]></summary></entry><entry><title type="html">TheRouter iOS 路由介绍</title><link href="http://localhost:4000/docs/2023/07/24/01" rel="alternate" type="text/html" title="TheRouter iOS 路由介绍" /><published>2023-07-24T00:00:00+08:00</published><updated>2023-07-24T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/07/24/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/07/24/01"><![CDATA[<h2 id="功能介绍">功能介绍</h2>

<p>TheRouter 是货拉拉打造的一款同时支持 <a href="https://github.com/HuolalaTech/hll-wp-therouter-android">Android</a> 及 <a href="https://github.com/HuolalaTech/hll-wp-therouter-ios">iOS</a> 的轻量级路由中间件，在iOS端吸取了其他其他语言的特性，支持<a href="https://juejin.cn/post/6999484997782470669">注解</a>功能，极大提升了路由在iOS端的使用体感。摒弃了传统 iOSer 的 target-action 或 protocol 理念，向更广的后台或 Android 应用对齐。</p>

<p><code class="language-plaintext highlighter-rouge">TheRouter 核心功能具备四大能力：</code></p>

<ul>
  <li><strong>页面导航跳转能力</strong>：支持常规 VC 或 Storyboard 的 push/present 跳转能力；</li>
  <li><strong>自动注册能力</strong>：实现类似 Java 注解功能，在 VC 类或任意方法上标注即可完成路由注册；</li>
  <li><strong>硬编码消除</strong>：内置脚本会自动将注册的 path 转为静态字符串常量供业务使用；</li>
  <li><strong>动态化能力</strong>：支持添加重定向、拦截器等等；</li>
</ul>

<h2 id="模块描述">模块描述</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── Classes
│   ├── TheRouter+Annotation.h
│   ├── TheRouter+Annotation.m  // 路由注解器及Path功能扩展
│   ├── TheRouter.h
│   └── TheRouter.m             // 路由库核心代码（增删改查，重定向/拦截器）
└── Resources
    └── scan.py                 // 注解扫描及硬编码处理脚本（该脚本只会被引用不会参与编译和打包）
</code></pre></div></div>

<h2 id="使用介绍">使用介绍</h2>

<h4 id="cocoapods-引入">Cocoapods 引入</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pod</span> <span class="s1">'TheRouter'</span>
</code></pre></div></div>

<h4 id="注解使用">注解使用</h4>

<p><strong>step1</strong></p>

<p>创建<code class="language-plaintext highlighter-rouge">TheRouterAnnotation.plist</code>文件，必须在MainBundle下。</p>

<p><strong>step2</strong></p>

<p>为项目创建一个Aggregate类型的target：</p>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/guide1.jpeg" class="blog-img" /></p>

<p><strong>step3</strong></p>

<p>在新建的target添加脚本：</p>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/guide2.jpeg" class="blog-img" /></p>

<p>图中实例脚本参数含义：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nv">$SRCROOT</span>/../TheRouter/Resources/scan.py     <span class="c"># 脚本路径</span>
<span class="nv">$SRCROOT</span>/                                           <span class="c"># 参数1：扫描路径,一般为项目根目录</span>
<span class="nv">$SRCROOT</span>/TheRouter/                                 <span class="c"># 参数2：路径定义头文件存放目录 一般为存放至公共模块 </span>
<span class="nv">$SRCROOT</span>/TheRouter/TheRouterAnnotation.plist        <span class="c"># 参数3：TheRouterAnnotation文件路径</span>
</code></pre></div></div>

<p><strong>step4</strong></p>

<p>在应用加载完成时注册host，在想要跳转的VC类上添加路由注解或创建对应模块的Service类，在Service中的方法上添加注解即可，例如：</p>

<p>注册该项目的host：</p>

<pre><code class="language-C">[TheRouter.shared registPathAnnotationsWithHost:@"hd://com.therouter.test"];
</code></pre>

<p>添加vc注解：</p>

<pre><code class="language-C">TheRouterController(test/vc, TestViewController)
@interface TestViewController : UIViewController

@end
</code></pre>

<p>添加Service注解：</p>

<pre><code class="language-C">#import "TestService.h"
#import "TheRouter_Mappings.h"
#import &lt;TheRouter/TheRouter+Annotation.h&gt;

@implementation TestService

TheRouterSelector(test/jump, jumpToTestVC, TestService)
+ (id)jumpToTestVC:(TheRouterInfo *)routerInfo
{
    UIViewController *vc = [TheRouter.shared openVCPath:kRouterPathTestVcVC
                                                    cmd:TheRouterOpenCMDPush
                                             withParams:@{@"title":@"123"}
                                                hanlder:^(NSString * _Nonnull tag, NSDictionary * _Nullable result) {
        !routerInfo.openCompleteHandler ?: routerInfo.openCompleteHandler(tag, result);
    }];
    return vc;
}

@end

</code></pre>

<p><strong>step5</strong></p>

<p>在每次对路由进行增删改时编译一次创建好的target，会自动向<code class="language-plaintext highlighter-rouge">TheRouterAnnotation.plist</code>文件写入信息，并在指定的目录下生成<code class="language-plaintext highlighter-rouge">TheRouter_Mappings.h</code>文件，将此文件拖入对应模块即可</p>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/guide3.jpeg" class="blog-img" /></p>

<h4 id="拦截器和重定向">拦截器和重定向</h4>

<p><strong>拦截器：</strong></p>

<pre><code class="language-C">// 只要访问hd://com.therouter.test或其子路径 (hd://com.therouter.test/xxx) 都会进入该回调
// 如果返回YES那么对应的路由事件可以正常执行，反之则会被拦截不会执行路由事件
[TheRouter.shared registInterceptorForURLString:@"hd://com.therouter.test/*" handler:^BOOL(TheRouterInfo * _Nonnull router, id  _Nullable (^ _Nonnull continueHandle)(void)) {
    NSLog(@"will execute router %@", router.URLString);
    return YES;
}];
</code></pre>

<p><strong>重定向：</strong></p>

<pre><code class="language-C">// 重定向是指访问 hd://test.com/test 时会走 hd://test.com/test/vc的事件，用来迁移老路径或线上遇到问题时可快速更改至其他页面承接业务
[TheRouter.shared registRedirect:@"hd://test.com/test" to:@"hd://test.com/test/vc"];
</code></pre>

<h4 id="执行路由事件">执行路由事件</h4>

<pre><code class="language-C">UIViewController *vc = [TheRouter.shared openVCPath:kRouterPathTestVcVC    // 传入Path
                                                cmd:TheRouterOpenCMDPush   // 指定打开命令
                                         withParams:@{@"title":@"123"}     // 指定参数，这里支持对kvc赋值
                                            hanlder:^(NSString * _Nonnull tag, NSDictionary * _Nullable result) {
        !routerInfo.openCompleteHandler ?: routerInfo.openCompleteHandler(tag, result);
}];
</code></pre>]]></content><author><name></name></author><category term="docs" /><category term="框架简介" /><summary type="html"><![CDATA[TheRouter 是货拉拉打造的一款同时支持 Android 及 iOS 的轻量级路由中间件，在iOS端吸取了其他其他语言的特性，支持注解功能，极大提升了路由在iOS端的使用体感。摒弃了传统 iOSer 的 target-action 或 protocol 理念，向更广的后台或 Android 应用对齐。]]></summary></entry><entry><title type="html">TheRouter 常见问题处理</title><link href="http://localhost:4000/docs/2023/07/21/01" rel="alternate" type="text/html" title="TheRouter 常见问题处理" /><published>2023-07-21T00:00:00+08:00</published><updated>2023-07-21T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/07/21/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/07/21/01"><![CDATA[<p>如无法解决你的问题，建议登记应用，获取优先技术支持 <a href="https://github.com/HuolalaTech/hll-wp-therouter-android/issues/57">https://github.com/HuolalaTech/hll-wp-therouter-android/issues/57</a></p>

<h3 id="问题列表不定期更新中">问题列表不定期更新中…</h3>

<hr />

<h4 id="q1-路由表不生成或生成的代码有问题编译报错">Q1: <strong>路由表不生成（或生成的代码有问题编译报错）</strong></h4>

<p>请按照以下步骤排查：</p>

<ol>
  <li>plugin 加了吗？plugin 必须加且只能加在 app 模块里。</li>
  <li>kapt加了吗？kapt不能只加最底层，所有用了注解的模块都要加。</li>
  <li>router、plugin、kapt，三个依赖的版本号必须一致。</li>
  <li>在这里查看JDK信息：<code class="language-plaintext highlighter-rouge">Preferences-&gt; Build Tools-&gt; Gradle-&gt; Gradle JDK</code>。不能用AS自带的jdk，KSP会有兼容问题，请在 Oracle 官网下载：<a href="https://www.oracle.com/hk/java/technologies/downloads/#java17">Java 17</a>、<a href="https://www.oracle.com/hk/java/technologies/downloads/#java11">Java 11</a>、<a href="https://www.oracle.com/hk/java/technologies/downloads/#java8">Java 8</a>。</li>
  <li>尝试更新至最新rc版本查看是否修复。<a href="https://github.com/HuolalaTech/hll-wp-therouter-android/releases">版本列表</a></li>
  <li>1.2.4 开始，路由表在增量编译时不会生成和校验，不影响实际使用，在release或非增量编译时会自动生成。详情可查阅构建日志中<code class="language-plaintext highlighter-rouge">TheRouter Environment</code>的内容。</li>
</ol>

<hr />

<h4 id="q2kotlin使用autowired注解编译不通过">Q2：<strong>kotlin使用<code class="language-plaintext highlighter-rouge">@Autowired</code>注解编译不通过</strong></h4>

<p>查看 GitHub Issue：<a href="https://github.com/HuolalaTech/hll-wp-therouter-android/issues/6">https://github.com/HuolalaTech/hll-wp-therouter-android/issues/6</a></p>

<hr />

<h4 id="q3使用gradle-8x编译报错">Q3：<strong>使用Gradle 8.X，编译报错</strong></h4>

<p><a href="https://github.com/HuolalaTech/hll-wp-therouter-android/issues/22">https://github.com/HuolalaTech/hll-wp-therouter-android/issues/22</a></p>

<hr />

<h4 id="q4从-arouter-迁移-therouter-时通过-bundle-传递的参数不能正确获取">Q4：<strong>从 ARouter 迁移 TheRouter 时通过 Bundle 传递的参数不能正确获取</strong></h4>

<p><a href="https://github.com/HuolalaTech/hll-wp-therouter-android/issues/29">https://github.com/HuolalaTech/hll-wp-therouter-android/issues/29</a></p>

<hr />

<h4 id="q5多进程如何使用">Q5：<strong>多进程如何使用</strong></h4>

<p><a href="https://therouter.cn/docs/2022/09/03/01">https://therouter.cn/docs/2022/09/03/01</a></p>

<hr />

<h4 id="q6同一个服务名有多个服务提供方如何使用">Q6：<strong>同一个服务名有多个服务提供方，如何使用</strong></h4>

<p>请查看文档 【1.3 服务提供方】章节的内容：<a href="https://therouter.cn/docs/2022/08/27/01">https://therouter.cn/docs/2022/08/27/01</a></p>

<hr />

<h4 id="q7多进程使用-therouter">Q7：多进程使用 TheRouter</h4>

<p>TheRouter 路由支持多进程，但默认只会在主进程执行初始化逻辑。如果使用了多进程，可以先关闭<code class="language-plaintext highlighter-rouge">TheRouter</code>的自动初始化，然后手动在<code class="language-plaintext highlighter-rouge">Application</code>的<code class="language-plaintext highlighter-rouge">onCreate()</code>中执行初始化功能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">override</span> <span class="n">fun</span> <span class="nf">attachBaseContext</span><span class="o">(</span><span class="nl">base:</span> <span class="nc">Context</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">attachBaseContext</span><span class="o">(</span><span class="n">base</span><span class="o">)</span>
    <span class="n">theRouterUseAutoInit</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="n">override</span> <span class="n">fun</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">()</span>
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注意</strong>：</p>

<ul>
  <li>1、多进程<code class="language-plaintext highlighter-rouge">ServiceProvider</code>，TheRouter 支持跨进程获取数据，但获取的数据本身需要支持跨进程，可以理解为<code class="language-plaintext highlighter-rouge">TheRouter</code>本质是个链接两个进程的通道，要将数据从一个进程传递到另一个进程，这个数据本身需要能够被另一个进程接收的到。</li>
  <li>2、<code class="language-plaintext highlighter-rouge">FlowTask</code>的跨进程依赖暂不支持，预计支持版本在<code class="language-plaintext highlighter-rouge">1.2.2</code>。</li>
  <li>3、<code class="language-plaintext highlighter-rouge">ActionManager</code>的跨进程响应暂不支持，预计支持版本在<code class="language-plaintext highlighter-rouge">1.2.2</code>。</li>
</ul>

<hr />

<h4 id="q8自定义log输出">Q8：自定义Log输出</h4>

<p>默认情况下，<code class="language-plaintext highlighter-rouge">TheRouter</code>会在<code class="language-plaintext highlighter-rouge">debug</code>模式下，将<code class="language-plaintext highlighter-rouge">log</code>打印到控制台，在<code class="language-plaintext highlighter-rouge">release</code>模式下不做任何输出。<br />
如果你希望采集线上日志信息，可以自定义<code class="language-plaintext highlighter-rouge">release</code>场景下的日志输出方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">override</span> <span class="n">fun</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 这一步建议放在Application.onCreate()之前，否则可能会在赋值之前就有部分日志已经执行了默认逻辑。</span>
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">logCat</span> <span class="o">=</span> <span class="o">{</span><span class="n">tag</span><span class="o">,</span> <span class="n">msg</span> <span class="o">-&gt;</span>  
        <span class="c1">// 执行上报日志的逻辑</span>
    <span class="o">}</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h4 id="q9判断string是否为路由path">Q9：判断String，是否为路由path</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断是否为路由落地页path</span>
<span class="nc">TheRouter</span><span class="o">.</span><span class="na">isRouterPath</span><span class="o">(</span><span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Boolean</span>  

<span class="c1">// 判断是否为 Action</span>
<span class="nc">TheRouter</span><span class="o">.</span><span class="na">isRouterAction</span><span class="o">(</span><span class="n">path</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Boolean</span>
</code></pre></div></div>

<hr />

<h4 id="q10导出路由历史记录">Q10：导出路由历史记录</h4>

<p>如果需要记录用户历史操作信息，用于排查错误时回放，可以直接使用历史记录导出功能：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// level共8个状态可选</span>
<span class="n">val</span> <span class="no">NONE</span> <span class="c1">// 不导出任何数据</span>
<span class="n">val</span> <span class="no">ACTIVITY</span> <span class="c1">//仅导出Activity的路由操作</span>
<span class="n">val</span> <span class="no">FRAGMENT</span> <span class="c1">//仅导出Fragment的路由操作</span>
<span class="n">val</span> <span class="no">PAGE</span>  <span class="c1">// 导出 Fragment + Activity的路由操作</span>
<span class="n">val</span> <span class="no">ACTION</span>  <span class="c1">// 导出 ActionManager 的操作记录</span>
<span class="n">val</span> <span class="no">SERVICE_PROVIDER</span> <span class="c1">// 导出 ServiceProvider的记录</span>
<span class="n">val</span> <span class="no">FLOW_TASK</span> <span class="c1">// 导出 FlowTaskExecutor 的历史记录</span>
<span class="n">val</span> <span class="no">ALL</span> <span class="c1">// 导出全部记录</span>

<span class="c1">// 8种状态可互相叠加，例如</span>
<span class="n">val</span> <span class="n">level</span> <span class="o">=</span> <span class="no">ACTIVITY</span> <span class="o">+</span> <span class="no">ACTION</span> <span class="o">+</span> <span class="no">FLOW_TASK</span>

<span class="nf">export</span><span class="o">(</span><span class="n">level</span><span class="o">).</span><span class="na">forEach</span> <span class="o">{</span>
    <span class="n">info</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">it</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h4 id="q11导入导出-intent-对象到路由">Q11：导入导出 Intent 对象到路由</h4>

<p>有一些特殊的业务场景可能必须使用<code class="language-plaintext highlighter-rouge">Intent</code>对象作为参数，例如通知栏点击以后，系统只提供了<code class="language-plaintext highlighter-rouge">Intent</code>参数，或者用于替代<code class="language-plaintext highlighter-rouge">startActivityForResult()</code>的新 API <code class="language-plaintext highlighter-rouge">ActivityResultLauncher</code> 。  <br />
TheRouter 也支持这样的使用场景：</p>

<p>导入 Intent：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TheRouter</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="n">intent</span><span class="o">).</span><span class="na">withXxxxx</span><span class="o">().</span><span class="na">navigation</span><span class="o">()</span>
</code></pre></div></div>

<p>导出 Intent：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注：导出Intent时，需要url有对应的落地页，否则Intent不会附带withXXX()的参数信息</span>
<span class="n">val</span> <span class="n">intent</span> <span class="o">=</span> <span class="nc">TheRouter</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="n">url</span><span class="o">).</span><span class="na">withXxxxx</span><span class="o">().</span><span class="na">createIntent</span><span class="o">()</span>
</code></pre></div></div>

<hr />

<h4 id="q12插件化项目集成">Q12：插件化项目集成</h4>

<p>TheRouter 的路由表是完全动态化的，所以允许动态加载插件路由表。
现有市面上插件化框架较多，具体可参考使用的插件化方案，当插件被加载时分别调用如下代码</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在异步线程执行</span>
<span class="n">execute</span> <span class="o">{</span>
    <span class="c1">// 初始化插件内的依赖注入</span>
    <span class="nc">TheRouterServiceProvideInjecter</span><span class="o">.</span><span class="na">trojan</span><span class="o">();</span>
    <span class="c1">// 初始化插件内的FlowTask</span>
    <span class="nc">TheRouterServiceProvideInjecter</span><span class="o">.</span><span class="na">addFlowTask</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="nc">TheRouter</span><span class="o">.</span><span class="na">digraph</span><span class="o">);</span>
    <span class="c1">// 初始化插件内的路由表</span>
    <span class="nc">TheRouterServiceProvideInjecter</span><span class="o">.</span><span class="na">initDefaultRouteMap</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h4 id="q13flutterrnweex-等混编项目集成">Q13：Flutter/RN/WEEX 等混编项目集成</h4>

<p>TheRouter 的路由表是完全动态化的，所以允许动态加载跨平台项目的路由表。</p>

<p>可以直接将路由表配置到<code class="language-plaintext highlighter-rouge">/assets/RouteMap.json</code>文件中。<br />
如果路由表的 <code class="language-plaintext highlighter-rouge">url</code> 是具备规律的，可简单使用正则表达式一次性加载。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://kymjs.com/flutter/</span><span class="se">\\</span><span class="s2">S*"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"className"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.therouter.FlutterActivity"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
    </span><span class="nl">"params"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"key"</span><span class="p">:</span><span class="s2">"value"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="err">......</span><span class="w">
  </span><span class="err">//</span><span class="w"> </span><span class="err">添加其他路由表</span><span class="w">
  </span><span class="err">......</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<hr />

<h4 id="q14我的项目使用的gradle8x或agp8引入插件失败">Q14：我的项目使用的Gradle8.x（或AGP8），引入插件失败</h4>

<p>请完整查看接入文档<a href="https://therouter.cn/docs/2022/11/23/01">https://therouter.cn/docs/2022/11/23/01</a>，并仔细阅读【第一步：接入classpath】</p>

<hr />

<h4 id="q15我为什么总是拉不到therouter的依赖">Q15：我为什么总是拉不到TheRouter的依赖</h4>

<p>TheRouter 的依赖全部上传在 <code class="language-plaintext highlighter-rouge">mavenCentral</code>，请检查你的仓库声明中是否有声明。另外，请不要使用阿里云的镜像仓库，否则也会造成拉不到依赖的情况。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>repositories {
    mavenCentral()
}
</code></pre></div></div>

<hr />

<h4 id="q16编译报错-api-androidregistertransform-is-removed">Q16：编译报错 <code class="language-plaintext highlighter-rouge">API 'android.registerTransform' is removed</code></h4>

<p>https://github.com/HuolalaTech/hll-wp-therouter-android/issues/121</p>

<hr />]]></content><author><name></name></author><category term="top" /><category term="框架简介" /><summary type="html"><![CDATA[前人踩过的坑，希望后人能跳过去。]]></summary></entry><entry><title type="html">TheRouter 使用 KSP 处理注解</title><link href="http://localhost:4000/docs/2023/05/15/01" rel="alternate" type="text/html" title="TheRouter 使用 KSP 处理注解" /><published>2023-05-15T00:00:00+08:00</published><updated>2023-05-15T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/05/15/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/05/15/01"><![CDATA[<p>TheRouter 在<code class="language-plaintext highlighter-rouge">1.1.4-rc2</code>开始，已经将<code class="language-plaintext highlighter-rouge">KSP</code>能力合并至主分支，不再是单独的功能分支了，下面介绍一下如何使用 <code class="language-plaintext highlighter-rouge">KSP</code>。</p>

<h3 id="什么是ksp">什么是KSP</h3>

<p>KSP全称：Kotlin Symbol Processing。<br />
借助官网的描述：KSP 提供了一种基于 Kotlin 的轻量级的编译期插件 API，其编译速度最快可以达到 kapt 速度的两倍。</p>

<p>从原理角度讲，<code class="language-plaintext highlighter-rouge">Android</code>项目构建过程中，可用的注解处理器总共有三种：APT、KAPT、KSP。<br />
APT 比较好理解，就是 JDK 提供的注解处理器，通常在 Gradle 项目中不需要引入什么额外插件，只需要在依赖时使用 <code class="language-plaintext highlighter-rouge">annotationProcessor "cn.therouter:apt:x.x.x</code>，但是他不支持 Kotlin 注解的解析。<br />
KAPT 最早是 Kotlin 推出的APT，用于兼容 Kotlin 代码的注解，但是他的实现比较简单粗暴，内部实际上是包了一层APT，他编译时首先处理 Kotlin 的注解解析，如果无法解析，再用APT去解析，所以相当于同一个模块，如果是Java、Kotlin混编时，会执行两遍注解解析。<br />
KSP 是基于语法分析的注解解析，严格来讲，他不仅仅可以用来做注解解析，还可以做一些基于语法分析的事情，比如自定义的代码语法检查，相当于替代了一部分 lint 可以做的事情。正因为基于语法分析来做的，所以性能必然是比 KAPT 高，毕竟编译期一定会先走一遍语法分析。</p>

<h3 id="therouter-的-ksp-使用">TheRouter 的 KSP 使用</h3>

<h4 id="第一步">第一步</h4>

<p>在项目中所有使用了注解的模块，对应的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件中都需要加入如下依赖，<strong>所有模块都要添加，不能只添加子模块</strong>：</p>

<p><strong>注意</strong> ，使用<code class="language-plaintext highlighter-rouge">KSP</code>以后，如果之前使用了<code class="language-plaintext highlighter-rouge">kapt</code>需要将原本的<code class="language-plaintext highlighter-rouge">kapt</code>依赖删掉</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Gradle7.x以下版本，这样加入 KSP插件</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">devtools</span><span class="o">.</span><span class="na">ksp</span><span class="err">'</span>
<span class="c1">// 删除之前的kapt依赖(如有)</span>
<span class="c1">// apply plugin: 'kotlin-kapt' </span>

<span class="c1">// Gradle7.x及以上版本，提供了新的方式，也这样加入 KSP插件</span>
<span class="c1">// 当然，也可以继续使用上面那种方式</span>
<span class="n">plugins</span> <span class="o">{</span>
    <span class="n">id</span> <span class="s">"com.google.devtools.ksp"</span>
    <span class="c1">// 删除之前的kapt依赖(如有)</span>
    <span class="c1">//id 'org.jetbrains.kotlin.kapt'</span>
<span class="o">}</span>


<span class="n">dependencies</span> <span class="o">{</span>
    <span class="c1">// 从1.1.4-rc2 开始在正式版本支持ksp，此前需要使用beta版本，但用法一致</span>
    <span class="n">ksp</span> <span class="s">"cn.therouter:apt:1.1.4-rc4"</span>
    <span class="c1">// 删除之前的kapt依赖(如有)</span>
    <span class="c1">// kapt "cn.therouter:apt:1.1.4-rc4"</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="第二步">第二步</h4>

<p>在项目根目录<code class="language-plaintext highlighter-rouge">build.gradle</code>引入 kapt 插件的 classpath :</p>

<p><strong>注意</strong>，版本号需要在KSP官网<a href="https://github.com/google/ksp/releases">https://github.com/google/ksp/releases</a>，找到跟自己项目中 Kotlin 版本号对应的<code class="language-plaintext highlighter-rouge">KSP</code>插件版本号。例如，我的 Kotlin 版本号是 <code class="language-plaintext highlighter-rouge">1.5.31</code>，所以 KSP 插件的版本号就使用对应的<code class="language-plaintext highlighter-rouge">1.5.31-1.0.0</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Gradle7.x以下版本，这样加入 </span>
<span class="n">buildscript</span> <span class="o">{</span>
	<span class="n">dependencies</span> <span class="o">{</span>
		<span class="n">classpath</span> <span class="s">"com.google.devtools.ksp:symbol-processing-gradle-plugin:xxx-xxx"</span>  
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Gradle7.x及以上版本，提供了新的方式，也这样加入  </span>
<span class="c1">// 当然，也可以继续使用上面那种方式</span>
<span class="n">plugins</span> <span class="o">{</span>
    <span class="n">id</span> <span class="s">"com.google.devtools.ksp"</span> <span class="n">version</span> <span class="err">'</span><span class="n">xxx</span><span class="o">-</span><span class="n">xxx</span><span class="err">'</span> <span class="n">apply</span> <span class="kc">false</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="docs" /><category term="基础能力介绍" /><summary type="html"><![CDATA[TheRouter 在1.1.4-rc2开始，已经将KSP能力合并至主分支，不再是单独的功能分支了，下面介绍一下如何使用 KSP。]]></summary></entry><entry><title type="html">动态路由 TheRouter 的设计与实践</title><link href="http://localhost:4000/docs/2022/12/23/01" rel="alternate" type="text/html" title="动态路由 TheRouter 的设计与实践" /><published>2022-12-23T00:00:00+08:00</published><updated>2022-12-23T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/12/23/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/12/23/01"><![CDATA[<p>内容请见：</p>

<p>《动态路由 TheRouter 的设计与实践》<br />
<a href="https://kymjs.com/session/2022/11/23/01/">https://kymjs.com/session/2022/11/23/01/</a></p>]]></content><author><name>张涛</name></author><category term="session" /><category term="原理与项目实践讲解" /><summary type="html"><![CDATA[详细讲解 TheRouter 框架内部实现原理，以及在完整企业级项目中使用的实践效果。这篇文章是我在 2022【GIAC 全球互联网架构大会】分享时所讲内容的文字版本，修改删减了演讲时的冗余言语，现开放给大家阅读，希望能给买不到票参加分享的 开源实验室 读者带来帮助。]]></summary></entry><entry><title type="html">从零接入 TheRouter</title><link href="http://localhost:4000/docs/2022/11/23/01" rel="alternate" type="text/html" title="从零接入 TheRouter" /><published>2022-11-23T00:00:00+08:00</published><updated>2022-11-23T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/11/23/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/11/23/01"><![CDATA[<p>TheRouter是货拉拉开源的路由框架，针对 Android 平台实现组件化、跨模块调用、动态化等功能的集成框架，基本上算当前最先进的路由库了。 <br />
Github: <a href="https://github.com/HuolalaTech/hll-wp-therouter-android/">https://github.com/HuolalaTech/hll-wp-therouter-android/</a> <br />
官网：<a href="http://therouter.cn/">http://therouter.cn/</a></p>

<h2 id="开始之前">开始之前</h2>

<p>如果你的项目之前使用过其他路由，建议使用迁移工具一键迁移： <a href="https://therouter.cn/docs/2022/09/05/01">https://therouter.cn/docs/2022/09/05/01</a></p>

<p>如果你的是新项目，请先记住一点：<strong>plugin、apt、router 三个依赖的版本号必须保持一致</strong>，请继续往下看接入步骤。</p>

<h2 id="查看最新版本">查看最新版本</h2>

<p>TheRouter 的版本分为两种，稳定版和 rc版，一般不追求新功能我们就用稳定版就行，可以在官网看到最新的版本号和各种版本的说明：<a href="https://therouter.cn/docs/2022/09/06/01">https://therouter.cn/docs/2022/09/06/01</a></p>

<h2 id="接入">接入</h2>

<p>新建一个<code class="language-plaintext highlighter-rouge">Demo</code>工程，打开<code class="language-plaintext highlighter-rouge">Demo</code>的根目录<code class="language-plaintext highlighter-rouge">build.gradle</code>。</p>

<h3 id="第一步接入classpath">第一步：接入classpath</h3>

<h4 id="8x-及以后版本-gradle">8.X 及以后版本 Gradle</h4>

<p><strong>注</strong>：<code class="language-plaintext highlighter-rouge">TheRouter 1.3.x</code>开始，可直接看<code class="language-plaintext highlighter-rouge">Gradle 7.x</code> 的接入方式，原因如下：</p>

<p>由于 8.X 版本的 Gradle，必须使用<code class="language-plaintext highlighter-rouge">Java 17</code>的环境，并且不兼容老<code class="language-plaintext highlighter-rouge">JDK</code>编译的<code class="language-plaintext highlighter-rouge">class</code>，所以对于新版本需要使用专为<code class="language-plaintext highlighter-rouge">Java 17</code>编译的插件。</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="s1">'cn.therouter.agp8'</span> <span class="n">version</span> <span class="s1">'1.2.4'</span> <span class="n">apply</span> <span class="kc">false</span>
</code></pre></div></div>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/1.png" class="blog-img" /></p>

<p><strong>20250228更新</strong>：从<code class="language-plaintext highlighter-rouge">1.3.x</code>开始，TheRouter 已经全部使用<code class="language-plaintext highlighter-rouge">Java 17</code>编译，也可以使用如下id引用：</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="s1">'cn.therouter'</span> <span class="n">version</span> <span class="s1">'1.3.x'</span> <span class="n">apply</span> <span class="kc">false</span>
</code></pre></div></div>

<h4 id="7x-版本-gradle">7.X 版本 Gradle</h4>

<p>7.X 的 Gradle，<code class="language-plaintext highlighter-rouge">classpath</code>已经改为用<code class="language-plaintext highlighter-rouge">plugins</code>的方式引入，只需要在闭包内加这一句就行了</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="s1">'cn.therouter'</span> <span class="n">version</span> <span class="s1">'1.3.0'</span> <span class="n">apply</span> <span class="kc">false</span>
</code></pre></div></div>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/2.jpg" class="blog-img" /></p>

<h4 id="6x-及之前的老版本-gradle">6.x 及之前的老版本 Gradle</h4>

<p>对于6.x 及之前的  Gradle，需要手动引入<code class="language-plaintext highlighter-rouge">classpath</code>，在 TheRouter 官方 Github 首页也有接入介绍</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">classpath</span> <span class="s2">"cn.therouter:plugin:1.3.0"</span>
</code></pre></div></div>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/3.jpg" class="blog-img" /></p>

<h3 id="第二步引入插件">第二步：引入插件</h3>

<h4 id="7x-及以后版本-gradle">7.X 及以后版本 Gradle</h4>

<p>找到项目里全部的app模块（一般只会有一个，特殊项目会有多个）。也就是整个工程的所有<code class="language-plaintext highlighter-rouge">build.gradle</code>文件里面，只要是有<code class="language-plaintext highlighter-rouge">com.android.application</code>这个的模块，都要加上如下代码</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 7.X及以上新版本这样写</span>
<span class="n">id</span> <span class="s1">'therouter'</span>
</code></pre></div></div>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/4.jpg" class="blog-img" /></p>

<h4 id="6x-及之前的老版本-gradle-1">6.x 及之前的老版本 Gradle</h4>

<p>找到项目里全部的app模块（一般只会有一个，特殊项目会有多个）。也就是整个工程的所有<code class="language-plaintext highlighter-rouge">build.gradle</code>文件里面，只要是有<code class="language-plaintext highlighter-rouge">com.android.application</code>这个的模块，都要加上如下代码</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 6.X及以下老版本这样写</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'therouter'</span>
</code></pre></div></div>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/5.jpg" class="blog-img" /></p>

<h3 id="第三步引入注解处理器">第三步：引入注解处理器</h3>

<p>最新版的 TheRouter 已经支持<code class="language-plaintext highlighter-rouge">KSP</code>解析，如果你都不知道<code class="language-plaintext highlighter-rouge">KSP</code>是什么，那么就继续往下看，使用<code class="language-plaintext highlighter-rouge">kapt</code>吧。如果你希望使用<code class="language-plaintext highlighter-rouge">KSP</code>，可以看文档：<a href="https://therouter.cn/docs/2023/05/15/01">使用 KSP 处理注解</a>。</p>

<p>TheRouter 的注解处理依赖<code class="language-plaintext highlighter-rouge">kapt</code>执行，所以要在项目里面手动引入，否则无法处理注解。</p>

<p><strong>注：所有的模块都必须引入kapt，否则就有可能造成某些路由表不生成。</strong><br />
<strong>注：所有APP的模块，如果是需要上线的模块，必须直接或间接在 app 中被依赖，否则最终生成apk会丢失未被依赖的功能。</strong></p>

<p><img src="https://cdn.kymjs.com:8843/therouter_assets/img/image/6.jpg" class="blog-img" /></p>

<p>如果报找不到kapt，可能是因为没有声明kotlin-kapt的插件，参考<code class="language-plaintext highlighter-rouge">步骤二</code>里面的截图，接入对应的kapt。<br />
如果是纯Java工程，需要用Java的APT处理，纯Java就不用声明<code class="language-plaintext highlighter-rouge">kotlin-kapt</code>插件了，直接把<code class="language-plaintext highlighter-rouge">kapt</code>改成<code class="language-plaintext highlighter-rouge">annotationProcessor</code></p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">annotationProcessor</span> <span class="s2">"cn.therouter:apt:1.3.0"</span>
</code></pre></div></div>

<h3 id="第四步引入路由库">第四步：引入路由库</h3>

<p>在需要使用路由功能的模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>，(不像kapt，这个是可以使用传递依赖的)，加入如下依赖</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    implementation "cn.therouter:router:1.3.0"
}
</code></pre></div></div>

<h2 id="使用">使用</h2>

<h4 id="1-声明路由">1. 声明路由</h4>

<p>给需要跳转的页面加上路由表声明</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Route</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"http://therouter.com/home"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HomeActivity</span> <span class="kd">extends</span> <span class="nc">BaseActivity</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="2-添加参数注入">2. 添加参数注入</h4>

<p>这一步如果在base里面写了的话就不用每个Activity都加了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">inject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-发起跳转">3. 发起跳转</h4>

<p>也就是原来使用startActivity()的方法，都可以改成这样使用了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="s">"要跳转的目标页Path"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withInt</span><span class="o">(</span><span class="s">"intValue"</span><span class="o">,</span> <span class="mi">12345678</span><span class="o">)</span> 
        <span class="o">.</span><span class="na">withString</span><span class="o">(</span><span class="s">"str_123_Value"</span><span class="o">,</span> <span class="s">"传中文字符串"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withBoolean</span><span class="o">(</span><span class="s">"boolValue"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withLong</span><span class="o">(</span><span class="s">"longValue"</span><span class="o">,</span> <span class="mi">123456789012345L</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withChar</span><span class="o">(</span><span class="s">"charValue"</span><span class="o">,</span> <span class="sc">'c'</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withDouble</span><span class="o">(</span><span class="s">"double"</span><span class="o">,</span> <span class="mf">3.14159265358972</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withFloat</span><span class="o">(</span><span class="s">"floatValue"</span><span class="o">,</span> <span class="mf">3.14159265358972</span><span class="no">F</span><span class="o">)</span>
        <span class="o">.</span><span class="na">navigation</span><span class="o">();</span>
        
    <span class="nc">TheRouter</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="s">"如果没有参数，可以什么都不传"</span><span class="o">).</span><span class="na">navigation</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="agp-8x-使用">AGP 8.X 使用</h2>

<p>从1.2.1开始，beta版本已经全部合入rc版本，无需再特殊关注beta版本进度。</p>

<p>从 1.3.0 开始，TheRouter 已全部使用 <code class="language-plaintext highlighter-rouge">Java17</code> 编译，无需区分<code class="language-plaintext highlighter-rouge">Gradle 8.x</code> 还是<code class="language-plaintext highlighter-rouge">7.x</code>。<br />
如果使用的是 1.3.x 之前的版本，使用时只需注意本文第一步中，id 引入的不同。</p>]]></content><author><name></name></author><category term="docs" /><category term="入门教程" /><summary type="html"><![CDATA[新手零基础入门教程。]]></summary></entry></feed>