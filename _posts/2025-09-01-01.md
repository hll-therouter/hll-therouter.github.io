---
layout: post
title: "Compose 使用介绍"
description: "现在也能支持 Compose 啦。从 1.3.1-rc1 版本开始，TheRouter 也支持 Jetpack Compose 了。    需要引入 compose 依赖："
categories: docs
level: 1
tag: "初级能力介绍"
android: true
---

本文不介绍引入框架依赖部分，如不了解如何引入依赖，请查看文档【从零接入 TheRouter】：[https://therouter.cn/docs/2022/11/23/01](https://therouter.cn/docs/2022/11/23/01)     

本文介绍的完整使用 demo 可以参考：[https://github.com/kymjs/TheRouterComposeDemo](https://github.com/kymjs/TheRouterComposeDemo)

从 1.3.1-rc1 版本开始，TheRouter 也支持 Jetpack Compose 了。    
需要引入 compose 依赖：   

```
implementation "cn.therouter:compose:1.3.1-rc1"
```

<br>

### 1.0 初始化

框架内部包含自动初始化功能，详见[单模块自动初始化能力](https://therouter.cn/docs/2022/08/26/01)
无需任何初始化代码。但推荐你根据业务设置否为`Debug`环境，用以查看日志信息。  
`Application.attachBaseContext()` 方法中尽可能早设置当前是否为`Debug`环境。  

```java
@Override
protected void attachBaseContext(Context base) {
    TheRouter.setDebug(true or false);
    super.attachBaseContext(base);
}
```  

<br>

### 1.1 声明 @Composable 页面(Screen)

关于注解`@Route`的参数含义，请查看文档：[页面导航跳转能力](https://therouter.cn/docs/2022/08/28/01)    

⚠️**注**：**@Composable页面必须是 top-level 级别函数**。

```kotlin
@Route(path = PathIndex.EMPTY_PAGE, description = "空白页面")
@Composable
fun EmptyComingSoon(modifier: Modifier = Modifier) {
 // xxxxx
}
```

<br>

@Composable 页面的函数定义允许有参数声明。     
⚠️**函数的参数有几个特殊注意点**：   

1. 如果参数是带泛型类型的，需要显示传递类型给TheRouter
2. 如果参数是 lambda 表达式，需要显示传递类型给TheRouter
3. 允许自定义函数参数的接收key（对应跳转页面时的传参）

前两点限制的主要原因是因为目前的 KSP 无法取到泛型类型的具体值(lambda 的本质也是一个泛型接口类)，因此只能手动传入，在未来的版本也许能解决。   

<br>


```kotlin
@Route(path = PathIndex.MAIN_PAGE, description = "主页")
@Composable
fun ReplyInboxScreen(
    // 普通对象或基本数据类型不需要做任何处理，默认接收key就是变量名
    contentType: ReplyContentType,
    
    // 可以通过注解修改参数的接收 key
    @Autowired(name = "hello_key")
    hello: String,
    
    // 如果参数是带泛型类型的，需要显示传递类型给TheRouter
    @Autowired(args = "List<androidx.window.layout.DisplayFeature>")
    displayFeatures: List<DisplayFeature>,
    
    // 如果参数是 lambda 表达式，需要显示传递类型给TheRouter
    @Autowired(args = "(Long) -> Unit")
    toggleSelectedEmail: (Long) -> Unit,
    
    // 有默认值的普通对象，或基本数据类型参数也不需要特殊处理
    modifier: Modifier = Modifier,
) {
//xxxxxxx
}
```

<br>

### 1.2 打开一个 @Composable 页面(Screen)

与原多 `Activity` 模式的跳转没有任何区别，只是结尾跳转的方法名变成了`compose()`  

compose() 函数本身也添加了 `@Composable` 注解，也就是说你可以将`TheRouter`与传统的 `NavHost` 混用(虽然不推荐)，而没有任何问题。    

```kotlin
TheRouter.build(PathIndex.MAIN_PAGE)
    .withObject("contentType", contentType)
    .withString("hello_key",“hello_key”)
    .withObject("displayFeatures", list)
    .withObject("toggleSelectedEmail", {arg-> println(arg)})
    .compose()
```

<br>

传递一个 @Composable 参数

<br>

```kotlin
TheRouter.build(PathIndex.SCREEN)
	// 入参已经声明过 @Composable ，可以直接使用
    .withComposableObject("content"){
        // xxxxxx
    }.compose()

@Composable
@Route(path = PathIndex.SCREEN)
fun ContrastAwareReplyTheme(dynamicColor: Boolean = false,
    // 如果参数是 lambda 表达式，需要显示传递类型给TheRouter
    @Autowired(args = "() -> Unit") 
    content: @Composable () -> Unit,
) {
	// xxxxx
}
```

<br>

### 动态 UI 应用

利用 TheRouter 的远端路由下发和路由表的动态性，可以做到线上环境千人千面，以及做到类似低代码UI的效果。    

* 客户端：提前预定义好各种UI模板（例如Column/Row/FrameLayout/以及 RecycleView 的各种 item），并将 UI 对应的 path 与后端统一。   

* 服务端：定义一套路由表与具体业务的模版。根据业务，对不同的人下发不同的 UI 组合。    

<br>

由于 Compose 支持嵌套，也就是一个 Compose Screen 作为另一个 Screen 的参数。用 TheRouter 来实现以后，也就是一个 path 允许关联多个子 path。 而这些 path 的关系靠后端维护，前端只负责渲染。  后端只需要对不同的人，返回不同的预定义 UI 模板的 json 即可。   
