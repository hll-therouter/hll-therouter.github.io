---
layout: post
title: "跨模块服务调用的设计与使用"
description: "新手零基础入门教程。   "
categories: docs  
level: 1
tag: "入门教程" 
harmony: true

---

`TheRouter` 是货拉拉基于HMRouter深度定制的开源路由框架，提供了 Android、iOS、Harmony 三端高一致性使用，在支持平台化应用实现组件化、跨模块调用、动态化等功能的集成等功能基础上，支持动态路由下发、编译时安全检查、路由Path一对多等高度动态能力。     

Github: [https://github.com/HuolalaTech/hll-wp-therouter-harmony/](https://github.com/HuolalaTech/hll-wp-therouter-harmony/)   
官网：[http://therouter.cn/](http://therouter.cn/)  

<br>

## ServiceProvider 的使用

对于模块化开发中跨模块的调用，我们推荐采用 [SOA(面向服务架构)](https://zh.m.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84) 的设计方式，服务调用方与使用方完全隔离，调用模块外的能力不需要关注能力的提供者是谁。  
`ServiceProvider` 的核心设计思想也是这样的，目前服务间的调用协议采用接口的方式。当然，也可以兼容不通过接口下沉而是直接调用的情况。  

<img src="https://cdn.kymjs.com:8843/qiniu/images/blog_image/therouter/3.jpeg" class="blog-img"/>

- 服务提供方负责提供服务，不需要关心调用方是谁会在何时调用自己。  
- 服务的使用方只关注服务本身，不需要关心这个服务是谁提供的，只需要只能服务能提供哪些能力即可。  

例如上面的图片：拉拉需要使用录音的服务，小货则向外提供一个录音的服务，由`TheRouter`的`ServiceProvider`负责撮合。  

<br>

#### 服务使用方：拉拉

她无需关心，`IRecordService` 这个接口服务是谁提供的，他只需要知道自己需要使用这样的一个服务就行了。  
注：如果没有提供服务的提供方，`TheRouter.get()` 可能返回 `undefined`  

```typescript
TheRouter.get<IRecordService>(BaseConstant.CLASS_SERVICE)?.doRecord()
```

<br>

#### 服务提供方：小货  

服务提供方需要声明一个提供服务的方法，用 `@ServiceProvider` 注解标记，并需要实现接口 `IServiceProvider`。  

```typescript

// 类名不限定，任意名字都行
// 所有的 ServiceProvider 必须实现 IServiceProvider 接口
// 多次添加重复serviceName，框架会保证安全，在编译时报错
@ServiceProvider({ serviceName: BaseConstant.CLASS_SERVICE, singleton: true })
export class CustomService implements IRecordService, IServiceProvider {

  doRecord(): void {
  }
}

```

<br>

**@ServiceProvider 参数释义**   
 
* **serviceName**: 服务名 【必传】。   
 服务的唯一标识。如果重复，在编译期会直接报错。   
* **singleton**: 默认false【可选】。  
 服务提供方提供出的服务是否为单例。   

<br>

## ServiceProvider 的设计原理

跨模块调用分为两部分，服务的提供方和服务的使用方

<br>

### 服务的提供方

与 Android 的设计思路一致，在编译时，通过解析注解 `@ServiceProvider` 获取到添加注解的类或方法。   

因为鸿蒙编译时的限制，不能像 Android 那样，通过动态修改某个指定类达到修改代码的目的。所以在鸿蒙里面，是将这些编译时的信息都记录到了路由表里面。因此你可以看到，TheRouter在编译以后的路由表，所有服务相关的调用前，都加了`__service_provider__` 这样的前缀，就是用来区分这个 path 是一个页面还是一个服务提供者。  

再当应用启动的时候，通过解析路由表，就可以拿到这些服务提供者的类、方法、接口名等等一系列信息了，并将这些信息序列化成对象，存在一个内存Map中。   

<br>

### 服务的使用方   

```typescript
  /**
   * 获取指定服务提供者提供的服务
   * @param serviceProvider
   * @returns
   */
  static get<T extends IServiceProvider>(serviceProvider: string): T {
    return RouterInject.getInstance().getService<T>(serviceProvider);
  }
```

当调用 `TheRouter.get()`时，其实就是去到了上面服务提供方的那个Map里面，找到本次需要调用的服务提供者，再去调用服务提供者对应的服务即可。   

然后`TheRouter`顺带还对服务提供者，做了单例、缓存、无缓存的设计，用来对应不同的业务场景需求。其实这些设计也都是对这个缓存Map做不同的处理而已。    

<br><br>

## 问题排查万能公式  

在使用过程中，如果发现服务无法调用，或返回为空的时候。通常的排查方式都是以下三步：   

1. 首先观察接入环境。插件是否和依赖库版本一致，插件是否生效了。在我们内部使用的过程中，经常发现，`oh-package.json5` 中引入的明明是新版本，但是实际编译时使用的还是老版本，猜测应该是构建工具的问题。在`TheRouter`编译时，日志的第一行就会有当前编译实际使用的版本号，如果和你预期不一致时，需要再执行一下命令行：

```shell
// 引入代码库依赖
ohpm i @therouter/library   

// 引入插件依赖
npm i @therouter/plugin
```

<br>

2.上一步排查完依然无法调用时，就要考虑一下是不是代码使用姿势问题了。比如添加`@ServiceProvider`的服务提供者必须实现`IServiceProvider`接口。服务提供者注解参数里面的`serviceName`是不是和使用方传入的一致。注：如果多次添加重复serviceName，框架会保证安全，在编译时报错。    

<br>

3.如果上两步都不能解决你的问题，那就需要进源码通过断点调试进一步明确问题出在哪里了。首先从`TheRouter.init()`开始找，看看路由表读取是否正确，再看服务Map里面是否有记录成功，再看调用的时候传入的是否正确，一步一步排查。   

